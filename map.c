/* map.c generated by valac 0.16.0, the Vala compiler
 * generated from map.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <SDL.h>
#include <gee.h>
#include <string.h>
#include <stdlib.h>
#include <gio/gio.h>
#include <SDL_image.h>


#define STK_TYPE_WIDGET (stk_widget_get_type ())
#define STK_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), STK_TYPE_WIDGET, StkWidget))
#define STK_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), STK_TYPE_WIDGET, StkWidgetClass))
#define STK_IS_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), STK_TYPE_WIDGET))
#define STK_IS_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), STK_TYPE_WIDGET))
#define STK_WIDGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), STK_TYPE_WIDGET, StkWidgetClass))

typedef struct _StkWidget StkWidget;
typedef struct _StkWidgetClass StkWidgetClass;
typedef struct _StkWidgetPrivate StkWidgetPrivate;

#define SYNERGIA_TYPE_MAP (synergia_map_get_type ())
#define SYNERGIA_MAP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYNERGIA_TYPE_MAP, SynergiaMap))
#define SYNERGIA_MAP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SYNERGIA_TYPE_MAP, SynergiaMapClass))
#define SYNERGIA_IS_MAP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYNERGIA_TYPE_MAP))
#define SYNERGIA_IS_MAP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SYNERGIA_TYPE_MAP))
#define SYNERGIA_MAP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SYNERGIA_TYPE_MAP, SynergiaMapClass))

typedef struct _SynergiaMap SynergiaMap;
typedef struct _SynergiaMapClass SynergiaMapClass;
typedef struct _SynergiaMapPrivate SynergiaMapPrivate;

#define SYNERGIA_TYPE_CHUNK (synergia_chunk_get_type ())
#define SYNERGIA_CHUNK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYNERGIA_TYPE_CHUNK, SynergiaChunk))
#define SYNERGIA_CHUNK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SYNERGIA_TYPE_CHUNK, SynergiaChunkClass))
#define SYNERGIA_IS_CHUNK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYNERGIA_TYPE_CHUNK))
#define SYNERGIA_IS_CHUNK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SYNERGIA_TYPE_CHUNK))
#define SYNERGIA_CHUNK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SYNERGIA_TYPE_CHUNK, SynergiaChunkClass))

typedef struct _SynergiaChunk SynergiaChunk;
typedef struct _SynergiaChunkClass SynergiaChunkClass;

#define SYNERGIA_TYPE_CHARACTER (synergia_character_get_type ())
#define SYNERGIA_CHARACTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYNERGIA_TYPE_CHARACTER, SynergiaCharacter))
#define SYNERGIA_CHARACTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SYNERGIA_TYPE_CHARACTER, SynergiaCharacterClass))
#define SYNERGIA_IS_CHARACTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYNERGIA_TYPE_CHARACTER))
#define SYNERGIA_IS_CHARACTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SYNERGIA_TYPE_CHARACTER))
#define SYNERGIA_CHARACTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SYNERGIA_TYPE_CHARACTER, SynergiaCharacterClass))

typedef struct _SynergiaCharacter SynergiaCharacter;
typedef struct _SynergiaCharacterClass SynergiaCharacterClass;

#define SYNERGIA_TYPE_PLAYER (synergia_player_get_type ())
#define SYNERGIA_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYNERGIA_TYPE_PLAYER, SynergiaPlayer))
#define SYNERGIA_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SYNERGIA_TYPE_PLAYER, SynergiaPlayerClass))
#define SYNERGIA_IS_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYNERGIA_TYPE_PLAYER))
#define SYNERGIA_IS_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SYNERGIA_TYPE_PLAYER))
#define SYNERGIA_PLAYER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SYNERGIA_TYPE_PLAYER, SynergiaPlayerClass))

typedef struct _SynergiaPlayer SynergiaPlayer;
typedef struct _SynergiaPlayerClass SynergiaPlayerClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _SDL_FreeSurface0(var) ((var == NULL) ? NULL : (var = (SDL_FreeSurface (var), NULL)))

#define SYNERGIA_TYPE_NET_CONNECTOR (synergia_net_connector_get_type ())
#define SYNERGIA_NET_CONNECTOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYNERGIA_TYPE_NET_CONNECTOR, SynergiaNetConnector))
#define SYNERGIA_NET_CONNECTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SYNERGIA_TYPE_NET_CONNECTOR, SynergiaNetConnectorClass))
#define SYNERGIA_IS_NET_CONNECTOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYNERGIA_TYPE_NET_CONNECTOR))
#define SYNERGIA_IS_NET_CONNECTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SYNERGIA_TYPE_NET_CONNECTOR))
#define SYNERGIA_NET_CONNECTOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SYNERGIA_TYPE_NET_CONNECTOR, SynergiaNetConnectorClass))

typedef struct _SynergiaNetConnector SynergiaNetConnector;
typedef struct _SynergiaNetConnectorClass SynergiaNetConnectorClass;
typedef struct _SynergiaCharacterPrivate SynergiaCharacterPrivate;

#define SYNERGIA_TYPE_ORIENTATION (synergia_orientation_get_type ())
typedef struct _SynergiaNetConnectorPrivate SynergiaNetConnectorPrivate;

#define SYNERGIA_TYPE_EVENTS (synergia_events_get_type ())
#define SYNERGIA_EVENTS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYNERGIA_TYPE_EVENTS, SynergiaEvents))
#define SYNERGIA_EVENTS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SYNERGIA_TYPE_EVENTS, SynergiaEventsClass))
#define SYNERGIA_IS_EVENTS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYNERGIA_TYPE_EVENTS))
#define SYNERGIA_IS_EVENTS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SYNERGIA_TYPE_EVENTS))
#define SYNERGIA_EVENTS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SYNERGIA_TYPE_EVENTS, SynergiaEventsClass))

typedef struct _SynergiaEvents SynergiaEvents;
typedef struct _SynergiaEventsClass SynergiaEventsClass;
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _SynergiaChunkPrivate SynergiaChunkPrivate;

#define SYNERGIA_TYPE_TILE (synergia_tile_get_type ())
typedef struct _SynergiaTile SynergiaTile;
#define _synergia_chunk_unref0(var) ((var == NULL) ? NULL : (var = (synergia_chunk_unref (var), NULL)))

struct _StkWidget {
	GObject parent_instance;
	StkWidgetPrivate * priv;
	SDL_Rect rect;
	gboolean focused;
};

struct _StkWidgetClass {
	GObjectClass parent_class;
	gboolean (*draw) (StkWidget* self, SDL_Surface* screen);
};

struct _SynergiaMap {
	StkWidget parent_instance;
	SynergiaMapPrivate * priv;
};

struct _SynergiaMapClass {
	StkWidgetClass parent_class;
};

struct _SynergiaMapPrivate {
	GeeList* chunks;
	SDL_Surface* tileset;
	SynergiaPlayer* player;
	SDL_Rect offset;
	GeeList* characters;
};

typedef enum  {
	SYNERGIA_ORIENTATION_NORTH = 3,
	SYNERGIA_ORIENTATION_SOUTH = 0,
	SYNERGIA_ORIENTATION_EAST = 2,
	SYNERGIA_ORIENTATION_WEST = 1
} SynergiaOrientation;

struct _SynergiaCharacter {
	StkWidget parent_instance;
	SynergiaCharacterPrivate * priv;
	SDL_Surface* sprite;
	SDL_Surface* nameSurface;
	SynergiaOrientation orientation;
	gint frame;
	SDL_Rect pos;
	SDL_Rect offset;
	gint id;
	gint16 motion;
	gchar* name;
	gint16 move_offset;
	SynergiaOrientation move_orientation;
};

struct _SynergiaCharacterClass {
	StkWidgetClass parent_class;
};

struct _SynergiaNetConnector {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SynergiaNetConnectorPrivate * priv;
	gchar* address;
	gint port;
	GSocket* socket;
	SynergiaEvents* events;
};

struct _SynergiaNetConnectorClass {
	GTypeClass parent_class;
	void (*finalize) (SynergiaNetConnector *self);
};

struct _SynergiaTile {
	gchar* value;
	gboolean crossable;
	gboolean set;
};

struct _SynergiaChunk {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SynergiaChunkPrivate * priv;
	SynergiaTile* data;
	gint data_length1;
	gint x;
	gint y;
};

struct _SynergiaChunkClass {
	GTypeClass parent_class;
	void (*finalize) (SynergiaChunk *self);
};


static gpointer synergia_map_parent_class = NULL;

GType stk_widget_get_type (void) G_GNUC_CONST;
GType synergia_map_get_type (void) G_GNUC_CONST;
gpointer synergia_chunk_ref (gpointer instance);
void synergia_chunk_unref (gpointer instance);
GParamSpec* synergia_param_spec_chunk (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void synergia_value_set_chunk (GValue* value, gpointer v_object);
void synergia_value_take_chunk (GValue* value, gpointer v_object);
gpointer synergia_value_get_chunk (const GValue* value);
GType synergia_chunk_get_type (void) G_GNUC_CONST;
GType synergia_character_get_type (void) G_GNUC_CONST;
GType synergia_player_get_type (void) G_GNUC_CONST;
#define SYNERGIA_MAP_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SYNERGIA_TYPE_MAP, SynergiaMapPrivate))
enum  {
	SYNERGIA_MAP_DUMMY_PROPERTY
};
gpointer synergia_net_connector_ref (gpointer instance);
void synergia_net_connector_unref (gpointer instance);
GParamSpec* synergia_param_spec_net_connector (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void synergia_value_set_net_connector (GValue* value, gpointer v_object);
void synergia_value_take_net_connector (GValue* value, gpointer v_object);
gpointer synergia_value_get_net_connector (const GValue* value);
GType synergia_net_connector_get_type (void) G_GNUC_CONST;
SynergiaMap* synergia_map_new (SynergiaNetConnector* net, SynergiaPlayer* p, GeeList* characters);
SynergiaMap* synergia_map_construct (GType object_type, SynergiaNetConnector* net, SynergiaPlayer* p, GeeList* characters);
StkWidget* stk_widget_new (void);
StkWidget* stk_widget_construct (GType object_type);
GType synergia_orientation_get_type (void) G_GNUC_CONST;
gpointer synergia_events_ref (gpointer instance);
void synergia_events_unref (gpointer instance);
GParamSpec* synergia_param_spec_events (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void synergia_value_set_events (GValue* value, gpointer v_object);
void synergia_value_take_events (GValue* value, gpointer v_object);
gpointer synergia_value_get_events (const GValue* value);
GType synergia_events_get_type (void) G_GNUC_CONST;
void synergia_map_UpdateChunk (SynergiaMap* self, gchar** command, int command_length1);
static void _synergia_map_UpdateChunk_synergia_events_chunk (SynergiaEvents* _sender, gchar** args, int args_length1, gpointer self);
void synergia_map_ChangeTileset (SynergiaMap* self, gchar** command, int command_length1);
static void _synergia_map_ChangeTileset_synergia_events_change_tileset (SynergiaEvents* _sender, gchar** args, int args_length1, gpointer self);
GType synergia_tile_get_type (void) G_GNUC_CONST;
SynergiaTile* synergia_tile_dup (const SynergiaTile* self);
void synergia_tile_free (SynergiaTile* self);
void synergia_tile_copy (const SynergiaTile* self, SynergiaTile* dest);
void synergia_tile_destroy (SynergiaTile* self);
SynergiaChunk* synergia_chunk_new (gint x, gint y, SynergiaTile* data, int data_length1);
SynergiaChunk* synergia_chunk_construct (GType object_type, gint x, gint y, SynergiaTile* data, int data_length1);
static void _vala_SynergiaTile_array_free (SynergiaTile* array, gint array_length);
static gboolean synergia_map_real_draw (StkWidget* base, SDL_Surface* screen);
gboolean stk_widget_draw (StkWidget* self, SDL_Surface* screen);
static void synergia_map_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _synergia_map_UpdateChunk_synergia_events_chunk (SynergiaEvents* _sender, gchar** args, int args_length1, gpointer self) {
	synergia_map_UpdateChunk (self, args, args_length1);
}


static void _synergia_map_ChangeTileset_synergia_events_change_tileset (SynergiaEvents* _sender, gchar** args, int args_length1, gpointer self) {
	synergia_map_ChangeTileset (self, args, args_length1);
}


SynergiaMap* synergia_map_construct (GType object_type, SynergiaNetConnector* net, SynergiaPlayer* p, GeeList* characters) {
	SynergiaMap * self = NULL;
	SynergiaPlayer* _tmp0_;
	SynergiaPlayer* _tmp1_;
	SynergiaPlayer* _tmp2_;
	SDL_Rect _tmp3_;
	GeeArrayList* _tmp4_;
	GeeList* _tmp5_;
	GeeList* _tmp6_;
	SynergiaNetConnector* _tmp7_;
	SynergiaEvents* _tmp8_;
	SynergiaNetConnector* _tmp9_;
	SynergiaEvents* _tmp10_;
	g_return_val_if_fail (net != NULL, NULL);
	g_return_val_if_fail (p != NULL, NULL);
	g_return_val_if_fail (characters != NULL, NULL);
	self = (SynergiaMap*) stk_widget_construct (object_type);
	_tmp0_ = p;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->player);
	self->priv->player = _tmp1_;
	memset (&self->priv->offset, 0, sizeof (SDL_Rect));
	_tmp2_ = self->priv->player;
	_tmp3_ = self->priv->offset;
	((SynergiaCharacter*) _tmp2_)->offset = _tmp3_;
	_tmp4_ = gee_array_list_new (SYNERGIA_TYPE_CHUNK, (GBoxedCopyFunc) synergia_chunk_ref, synergia_chunk_unref, NULL);
	_g_object_unref0 (self->priv->chunks);
	self->priv->chunks = (GeeList*) _tmp4_;
	_tmp5_ = characters;
	_tmp6_ = _g_object_ref0 (_tmp5_);
	_g_object_unref0 (self->priv->characters);
	self->priv->characters = _tmp6_;
	_tmp7_ = net;
	_tmp8_ = _tmp7_->events;
	g_signal_connect_object (_tmp8_, "chunk", (GCallback) _synergia_map_UpdateChunk_synergia_events_chunk, self, 0);
	_tmp9_ = net;
	_tmp10_ = _tmp9_->events;
	g_signal_connect_object (_tmp10_, "change-tileset", (GCallback) _synergia_map_ChangeTileset_synergia_events_change_tileset, self, 0);
	return self;
}


SynergiaMap* synergia_map_new (SynergiaNetConnector* net, SynergiaPlayer* p, GeeList* characters) {
	return synergia_map_construct (SYNERGIA_TYPE_MAP, net, p, characters);
}


void synergia_map_ChangeTileset (SynergiaMap* self, gchar** command, int command_length1) {
	gchar** _tmp0_;
	gint _tmp0__length1;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	SDL_Surface* _tmp6_ = NULL;
	SDL_Surface* _tmp7_;
	g_return_if_fail (self != NULL);
	_tmp0_ = command;
	_tmp0__length1 = command_length1;
	_tmp1_ = _tmp0_[0];
	_tmp2_ = g_strconcat ("gfx/tilesets/", _tmp1_, NULL);
	_tmp3_ = _tmp2_;
	_tmp4_ = g_strconcat (_tmp3_, ".png", NULL);
	_tmp5_ = _tmp4_;
	_tmp6_ = IMG_Load (_tmp5_);
	_SDL_FreeSurface0 (self->priv->tileset);
	self->priv->tileset = _tmp6_;
	_g_free0 (_tmp5_);
	_g_free0 (_tmp3_);
	_tmp7_ = self->priv->tileset;
	SDL_SetAlpha (_tmp7_, (guint32) 0, (guchar) 0);
}


static void _vala_SynergiaTile_array_free (SynergiaTile* array, gint array_length) {
	if (array != NULL) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			synergia_tile_destroy (&array[i]);
		}
	}
	g_free (array);
}


void synergia_map_UpdateChunk (SynergiaMap* self, gchar** command, int command_length1) {
	gchar** _tmp0_;
	gint _tmp0__length1;
	const gchar* _tmp1_;
	gint _tmp2_ = 0;
	gint x;
	gchar** _tmp3_;
	gint _tmp3__length1;
	const gchar* _tmp4_;
	gint _tmp5_ = 0;
	gint y;
	SynergiaTile* _tmp27_ = NULL;
	SynergiaTile* data;
	gint data_length1;
	gint _data_size_;
	gint _tmp63_;
	gint _tmp64_;
	SynergiaTile* _tmp65_;
	gint _tmp65__length1;
	SynergiaChunk* _tmp66_;
	SynergiaChunk* c;
	GeeList* _tmp67_;
	g_return_if_fail (self != NULL);
	_tmp0_ = command;
	_tmp0__length1 = command_length1;
	_tmp1_ = _tmp0_[0];
	_tmp2_ = atoi (_tmp1_);
	x = _tmp2_;
	_tmp3_ = command;
	_tmp3__length1 = command_length1;
	_tmp4_ = _tmp3_[1];
	_tmp5_ = atoi (_tmp4_);
	y = _tmp5_;
	{
		GeeList* _tmp6_;
		GeeList* _tmp7_;
		GeeList* _c_list;
		GeeList* _tmp8_;
		gint _tmp9_;
		gint _tmp10_;
		gint _c_size;
		gint _c_index;
		_tmp6_ = self->priv->chunks;
		_tmp7_ = _g_object_ref0 (_tmp6_);
		_c_list = _tmp7_;
		_tmp8_ = _c_list;
		_tmp9_ = gee_collection_get_size ((GeeCollection*) _tmp8_);
		_tmp10_ = _tmp9_;
		_c_size = _tmp10_;
		_c_index = -1;
		while (TRUE) {
			gint _tmp11_;
			gint _tmp12_;
			gint _tmp13_;
			GeeList* _tmp14_;
			gint _tmp15_;
			gpointer _tmp16_ = NULL;
			SynergiaChunk* c;
			gboolean _tmp17_ = FALSE;
			SynergiaChunk* _tmp18_;
			gint _tmp19_;
			gint _tmp20_;
			gboolean _tmp24_;
			_tmp11_ = _c_index;
			_c_index = _tmp11_ + 1;
			_tmp12_ = _c_index;
			_tmp13_ = _c_size;
			if (!(_tmp12_ < _tmp13_)) {
				break;
			}
			_tmp14_ = _c_list;
			_tmp15_ = _c_index;
			_tmp16_ = gee_list_get (_tmp14_, _tmp15_);
			c = (SynergiaChunk*) _tmp16_;
			_tmp18_ = c;
			_tmp19_ = _tmp18_->x;
			_tmp20_ = x;
			if (_tmp19_ == _tmp20_) {
				SynergiaChunk* _tmp21_;
				gint _tmp22_;
				gint _tmp23_;
				_tmp21_ = c;
				_tmp22_ = _tmp21_->y;
				_tmp23_ = y;
				_tmp17_ = _tmp22_ == _tmp23_;
			} else {
				_tmp17_ = FALSE;
			}
			_tmp24_ = _tmp17_;
			if (_tmp24_) {
				GeeList* _tmp25_;
				SynergiaChunk* _tmp26_;
				_tmp25_ = self->priv->chunks;
				_tmp26_ = c;
				gee_collection_remove ((GeeCollection*) _tmp25_, _tmp26_);
				_synergia_chunk_unref0 (c);
				break;
			}
			_synergia_chunk_unref0 (c);
		}
		_g_object_unref0 (_c_list);
	}
	_tmp27_ = g_new0 (SynergiaTile, 16);
	data = _tmp27_;
	data_length1 = 16;
	_data_size_ = data_length1;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp28_;
			_tmp28_ = TRUE;
			while (TRUE) {
				gboolean _tmp29_;
				gint _tmp31_;
				gchar** _tmp32_;
				gint _tmp32__length1;
				gint _tmp33_;
				const gchar* _tmp34_;
				_tmp29_ = _tmp28_;
				if (!_tmp29_) {
					gint _tmp30_;
					_tmp30_ = i;
					i = _tmp30_ + 1;
				}
				_tmp28_ = FALSE;
				_tmp31_ = i;
				if (!(_tmp31_ < 16)) {
					break;
				}
				_tmp32_ = command;
				_tmp32__length1 = command_length1;
				_tmp33_ = i;
				_tmp34_ = _tmp32_[_tmp33_ + 2];
				if (_tmp34_ != NULL) {
					gchar** _tmp35_;
					gint _tmp35__length1;
					gint _tmp36_;
					const gchar* _tmp37_;
					gchar** _tmp38_;
					gchar** _tmp39_ = NULL;
					gchar** tileinfo;
					gint tileinfo_length1;
					gint _tileinfo_size_;
					SynergiaTile* _tmp40_;
					gint _tmp40__length1;
					gint _tmp41_;
					SynergiaTile _tmp42_ = {0};
					SynergiaTile _tmp43_;
					SynergiaTile* _tmp44_;
					gint _tmp44__length1;
					gint _tmp45_;
					SynergiaTile* _tmp46_;
					gint _tmp46__length1;
					gint _tmp47_;
					gchar** _tmp48_;
					gint _tmp48__length1;
					const gchar* _tmp49_;
					gchar* _tmp50_;
					gboolean _tmp51_ = FALSE;
					gchar** _tmp52_;
					gint _tmp52__length1;
					const gchar* _tmp53_;
					SynergiaTile* _tmp54_;
					gint _tmp54__length1;
					gint _tmp55_;
					gboolean _tmp56_;
					_tmp35_ = command;
					_tmp35__length1 = command_length1;
					_tmp36_ = i;
					_tmp37_ = _tmp35_[_tmp36_ + 2];
					_tmp39_ = _tmp38_ = g_strsplit (_tmp37_, "/", 2);
					tileinfo = _tmp39_;
					tileinfo_length1 = _vala_array_length (_tmp38_);
					_tileinfo_size_ = tileinfo_length1;
					_tmp40_ = data;
					_tmp40__length1 = data_length1;
					_tmp41_ = i;
					memset (&_tmp42_, 0, sizeof (SynergiaTile));
					synergia_tile_destroy (&_tmp40_[_tmp41_]);
					_tmp40_[_tmp41_] = _tmp42_;
					_tmp43_ = _tmp40_[_tmp41_];
					_tmp44_ = data;
					_tmp44__length1 = data_length1;
					_tmp45_ = i;
					_tmp44_[_tmp45_].set = TRUE;
					_tmp46_ = data;
					_tmp46__length1 = data_length1;
					_tmp47_ = i;
					_tmp48_ = tileinfo;
					_tmp48__length1 = tileinfo_length1;
					_tmp49_ = _tmp48_[0];
					_tmp50_ = g_strdup (_tmp49_);
					_g_free0 (_tmp46_[_tmp47_].value);
					_tmp46_[_tmp47_].value = _tmp50_;
					_tmp52_ = tileinfo;
					_tmp52__length1 = tileinfo_length1;
					_tmp53_ = _tmp52_[1];
					if (g_strcmp0 (_tmp53_, "1") == 0) {
						_tmp51_ = TRUE;
					} else {
						_tmp51_ = FALSE;
					}
					_tmp54_ = data;
					_tmp54__length1 = data_length1;
					_tmp55_ = i;
					_tmp56_ = _tmp51_;
					_tmp54_[_tmp55_].crossable = _tmp56_;
					tileinfo = (_vala_array_free (tileinfo, tileinfo_length1, (GDestroyNotify) g_free), NULL);
				} else {
					SynergiaTile* _tmp57_;
					gint _tmp57__length1;
					gint _tmp58_;
					SynergiaTile _tmp59_ = {0};
					SynergiaTile _tmp60_;
					SynergiaTile* _tmp61_;
					gint _tmp61__length1;
					gint _tmp62_;
					_tmp57_ = data;
					_tmp57__length1 = data_length1;
					_tmp58_ = i;
					memset (&_tmp59_, 0, sizeof (SynergiaTile));
					synergia_tile_destroy (&_tmp57_[_tmp58_]);
					_tmp57_[_tmp58_] = _tmp59_;
					_tmp60_ = _tmp57_[_tmp58_];
					_tmp61_ = data;
					_tmp61__length1 = data_length1;
					_tmp62_ = i;
					_tmp61_[_tmp62_].set = FALSE;
				}
			}
		}
	}
	_tmp63_ = x;
	_tmp64_ = y;
	_tmp65_ = data;
	_tmp65__length1 = data_length1;
	_tmp66_ = synergia_chunk_new (_tmp63_, _tmp64_, _tmp65_, _tmp65__length1);
	c = _tmp66_;
	_tmp67_ = self->priv->chunks;
	gee_collection_add ((GeeCollection*) _tmp67_, c);
	_synergia_chunk_unref0 (c);
	data = (_vala_SynergiaTile_array_free (data, data_length1), NULL);
}


static gboolean synergia_map_real_draw (StkWidget* base, SDL_Surface* screen) {
	SynergiaMap * self;
	gboolean result = FALSE;
	SDL_Surface* _tmp0_;
	gint tileint = 0;
	gint row = 0;
	gint col = 0;
	SDL_Rect src = {0};
	SDL_Rect dst = {0};
	gboolean _tmp1_ = FALSE;
	GeeList* _tmp2_;
	gint _tmp3_;
	gint _tmp4_;
	gboolean _tmp6_;
	SynergiaPlayer* _tmp7_;
	SDL_Rect _tmp8_;
	gint16 _tmp9_;
	SynergiaPlayer* _tmp10_;
	SDL_Rect _tmp11_;
	gint16 _tmp12_;
	SynergiaPlayer* _tmp13_;
	SDL_Rect _tmp14_;
	self = (SynergiaMap*) base;
	g_return_val_if_fail (screen != NULL, FALSE);
	_tmp0_ = screen;
	STK_WIDGET_CLASS (synergia_map_parent_class)->draw (STK_WIDGET (self), _tmp0_);
	_tmp2_ = self->priv->chunks;
	_tmp3_ = gee_collection_get_size ((GeeCollection*) _tmp2_);
	_tmp4_ = _tmp3_;
	if (_tmp4_ == 0) {
		_tmp1_ = TRUE;
	} else {
		SDL_Surface* _tmp5_;
		_tmp5_ = self->priv->tileset;
		_tmp1_ = _tmp5_ == NULL;
	}
	_tmp6_ = _tmp1_;
	if (_tmp6_) {
		result = TRUE;
		return result;
	}
	memset (&src, 0, sizeof (SDL_Rect));
	memset (&dst, 0, sizeof (SDL_Rect));
	dst.w = (guint16) 32;
	dst.h = (guint16) 32;
	src.w = (guint16) 32;
	src.h = (guint16) 32;
	_tmp7_ = self->priv->player;
	_tmp8_ = ((SynergiaCharacter*) _tmp7_)->pos;
	_tmp9_ = _tmp8_.x;
	self->priv->offset.x = (gint16) (_tmp9_ - 9);
	_tmp10_ = self->priv->player;
	_tmp11_ = ((SynergiaCharacter*) _tmp10_)->pos;
	_tmp12_ = _tmp11_.y;
	self->priv->offset.y = (gint16) (_tmp12_ - 7);
	_tmp13_ = self->priv->player;
	_tmp14_ = self->priv->offset;
	((SynergiaCharacter*) _tmp13_)->offset = _tmp14_;
	{
		GeeList* _tmp15_;
		GeeList* _tmp16_;
		GeeList* _c_list;
		GeeList* _tmp17_;
		gint _tmp18_;
		gint _tmp19_;
		gint _c_size;
		gint _c_index;
		_tmp15_ = self->priv->characters;
		_tmp16_ = _g_object_ref0 (_tmp15_);
		_c_list = _tmp16_;
		_tmp17_ = _c_list;
		_tmp18_ = gee_collection_get_size ((GeeCollection*) _tmp17_);
		_tmp19_ = _tmp18_;
		_c_size = _tmp19_;
		_c_index = -1;
		while (TRUE) {
			gint _tmp20_;
			gint _tmp21_;
			gint _tmp22_;
			GeeList* _tmp23_;
			gint _tmp24_;
			gpointer _tmp25_ = NULL;
			SynergiaCharacter* c;
			SynergiaCharacter* _tmp26_;
			SDL_Rect _tmp27_;
			SynergiaCharacter* _tmp28_;
			SynergiaPlayer* _tmp29_;
			gint16 _tmp30_;
			SynergiaCharacter* _tmp31_;
			SynergiaPlayer* _tmp32_;
			SynergiaOrientation _tmp33_;
			_tmp20_ = _c_index;
			_c_index = _tmp20_ + 1;
			_tmp21_ = _c_index;
			_tmp22_ = _c_size;
			if (!(_tmp21_ < _tmp22_)) {
				break;
			}
			_tmp23_ = _c_list;
			_tmp24_ = _c_index;
			_tmp25_ = gee_list_get (_tmp23_, _tmp24_);
			c = (SynergiaCharacter*) _tmp25_;
			_tmp26_ = c;
			_tmp27_ = self->priv->offset;
			_tmp26_->offset = _tmp27_;
			_tmp28_ = c;
			_tmp29_ = self->priv->player;
			_tmp30_ = ((SynergiaCharacter*) _tmp29_)->motion;
			_tmp28_->move_offset = _tmp30_;
			_tmp31_ = c;
			_tmp32_ = self->priv->player;
			_tmp33_ = ((SynergiaCharacter*) _tmp32_)->orientation;
			_tmp31_->move_orientation = _tmp33_;
			_g_object_unref0 (c);
		}
		_g_object_unref0 (_c_list);
	}
	{
		GeeList* _tmp34_;
		GeeList* _tmp35_;
		GeeList* _c_list;
		GeeList* _tmp36_;
		gint _tmp37_;
		gint _tmp38_;
		gint _c_size;
		gint _c_index;
		_tmp34_ = self->priv->chunks;
		_tmp35_ = _g_object_ref0 (_tmp34_);
		_c_list = _tmp35_;
		_tmp36_ = _c_list;
		_tmp37_ = gee_collection_get_size ((GeeCollection*) _tmp36_);
		_tmp38_ = _tmp37_;
		_c_size = _tmp38_;
		_c_index = -1;
		while (TRUE) {
			gint _tmp39_;
			gint _tmp40_;
			gint _tmp41_;
			GeeList* _tmp42_;
			gint _tmp43_;
			gpointer _tmp44_ = NULL;
			SynergiaChunk* c;
			gint dx;
			gint dy;
			SynergiaChunk* _tmp45_;
			SynergiaTile* _tmp46_;
			gint _tmp46__length1;
			_tmp39_ = _c_index;
			_c_index = _tmp39_ + 1;
			_tmp40_ = _c_index;
			_tmp41_ = _c_size;
			if (!(_tmp40_ < _tmp41_)) {
				break;
			}
			_tmp42_ = _c_list;
			_tmp43_ = _c_index;
			_tmp44_ = gee_list_get (_tmp42_, _tmp43_);
			c = (SynergiaChunk*) _tmp44_;
			dx = 0;
			dy = 0;
			_tmp45_ = c;
			_tmp46_ = _tmp45_->data;
			_tmp46__length1 = _tmp45_->data_length1;
			{
				SynergiaTile* t_collection = NULL;
				gint t_collection_length1 = 0;
				gint _t_collection_size_ = 0;
				gint t_it = 0;
				t_collection = _tmp46_;
				t_collection_length1 = _tmp46__length1;
				for (t_it = 0; t_it < _tmp46__length1; t_it = t_it + 1) {
					SynergiaTile _tmp47_ = {0};
					SynergiaTile t = {0};
					synergia_tile_copy (&t_collection[t_it], &_tmp47_);
					t = _tmp47_;
					{
						SynergiaTile _tmp48_;
						gboolean _tmp49_;
						_tmp48_ = t;
						_tmp49_ = _tmp48_.set;
						if (_tmp49_ != FALSE) {
							SynergiaChunk* _tmp50_;
							gint _tmp51_;
							gint _tmp52_;
							SDL_Rect _tmp53_;
							gint16 _tmp54_;
							SynergiaChunk* _tmp55_;
							gint _tmp56_;
							gint _tmp57_;
							SDL_Rect _tmp58_;
							gint16 _tmp59_;
							SynergiaTile _tmp60_;
							const gchar* _tmp61_;
							gint _tmp62_ = 0;
							gint _tmp63_;
							gint _tmp64_;
							gint _tmp65_;
							gint _tmp66_;
							gint _tmp67_;
							gint16 _tmp68_;
							gint16 _tmp69_;
							SynergiaPlayer* _tmp70_;
							gint16 _tmp71_;
							gboolean _tmp86_ = FALSE;
							gboolean _tmp87_ = FALSE;
							gboolean _tmp88_ = FALSE;
							SDL_Rect _tmp89_;
							gint16 _tmp90_;
							gboolean _tmp95_;
							gboolean _tmp98_;
							gboolean _tmp103_;
							gint _tmp108_;
							gint _tmp109_;
							_tmp50_ = c;
							_tmp51_ = _tmp50_->x;
							_tmp52_ = dx;
							_tmp53_ = self->priv->offset;
							_tmp54_ = _tmp53_.x;
							dst.x = (gint16) ((_tmp51_ + _tmp52_) - _tmp54_);
							_tmp55_ = c;
							_tmp56_ = _tmp55_->y;
							_tmp57_ = dy;
							_tmp58_ = self->priv->offset;
							_tmp59_ = _tmp58_.y;
							dst.y = (gint16) ((_tmp56_ + _tmp57_) - _tmp59_);
							_tmp60_ = t;
							_tmp61_ = _tmp60_.value;
							_tmp62_ = atoi (_tmp61_);
							tileint = _tmp62_;
							_tmp63_ = tileint;
							row = _tmp63_ / 8;
							_tmp64_ = tileint;
							_tmp65_ = row;
							col = _tmp64_ - (_tmp65_ * 8);
							_tmp66_ = col;
							src.x = (gint16) (32 * _tmp66_);
							_tmp67_ = row;
							src.y = (gint16) (32 * _tmp67_);
							_tmp68_ = dst.x;
							dst.x = (gint16) (_tmp68_ * 32);
							_tmp69_ = dst.y;
							dst.y = (gint16) (_tmp69_ * 32);
							_tmp70_ = self->priv->player;
							_tmp71_ = ((SynergiaCharacter*) _tmp70_)->motion;
							if (((gint) _tmp71_) != 0) {
								SynergiaPlayer* _tmp72_;
								SynergiaOrientation _tmp73_;
								_tmp72_ = self->priv->player;
								_tmp73_ = ((SynergiaCharacter*) _tmp72_)->orientation;
								switch (_tmp73_) {
									case SYNERGIA_ORIENTATION_NORTH:
									{
										gint16 _tmp74_;
										SynergiaPlayer* _tmp75_;
										gint16 _tmp76_;
										_tmp74_ = dst.y;
										_tmp75_ = self->priv->player;
										_tmp76_ = ((SynergiaCharacter*) _tmp75_)->motion;
										dst.y = _tmp74_ - _tmp76_;
										break;
									}
									case SYNERGIA_ORIENTATION_SOUTH:
									{
										gint16 _tmp77_;
										SynergiaPlayer* _tmp78_;
										gint16 _tmp79_;
										_tmp77_ = dst.y;
										_tmp78_ = self->priv->player;
										_tmp79_ = ((SynergiaCharacter*) _tmp78_)->motion;
										dst.y = _tmp77_ + _tmp79_;
										break;
									}
									case SYNERGIA_ORIENTATION_EAST:
									{
										gint16 _tmp80_;
										SynergiaPlayer* _tmp81_;
										gint16 _tmp82_;
										_tmp80_ = dst.x;
										_tmp81_ = self->priv->player;
										_tmp82_ = ((SynergiaCharacter*) _tmp81_)->motion;
										dst.x = _tmp80_ + _tmp82_;
										break;
									}
									case SYNERGIA_ORIENTATION_WEST:
									{
										gint16 _tmp83_;
										SynergiaPlayer* _tmp84_;
										gint16 _tmp85_;
										_tmp83_ = dst.x;
										_tmp84_ = self->priv->player;
										_tmp85_ = ((SynergiaCharacter*) _tmp84_)->motion;
										dst.x = _tmp83_ - _tmp85_;
										break;
									}
									default:
									break;
								}
							}
							_tmp89_ = dst;
							_tmp90_ = _tmp89_.x;
							if (((gint) _tmp90_) >= (-31)) {
								SDL_Rect _tmp91_;
								gint16 _tmp92_;
								SDL_Surface* _tmp93_;
								gint _tmp94_;
								_tmp91_ = dst;
								_tmp92_ = _tmp91_.x;
								_tmp93_ = screen;
								_tmp94_ = _tmp93_->w;
								_tmp88_ = ((gint) _tmp92_) <= (_tmp94_ + 31);
							} else {
								_tmp88_ = FALSE;
							}
							_tmp95_ = _tmp88_;
							if (_tmp95_) {
								SDL_Rect _tmp96_;
								gint16 _tmp97_;
								_tmp96_ = dst;
								_tmp97_ = _tmp96_.y;
								_tmp87_ = ((gint) _tmp97_) >= (-31);
							} else {
								_tmp87_ = FALSE;
							}
							_tmp98_ = _tmp87_;
							if (_tmp98_) {
								SDL_Rect _tmp99_;
								gint16 _tmp100_;
								SDL_Surface* _tmp101_;
								gint _tmp102_;
								_tmp99_ = dst;
								_tmp100_ = _tmp99_.y;
								_tmp101_ = screen;
								_tmp102_ = _tmp101_->h;
								_tmp86_ = ((gint) _tmp100_) <= (_tmp102_ + 31);
							} else {
								_tmp86_ = FALSE;
							}
							_tmp103_ = _tmp86_;
							if (_tmp103_) {
								SDL_Surface* _tmp104_;
								SDL_Rect _tmp105_;
								SDL_Surface* _tmp106_;
								SDL_Rect _tmp107_;
								_tmp104_ = self->priv->tileset;
								_tmp105_ = src;
								_tmp106_ = screen;
								_tmp107_ = dst;
								SDL_UpperBlit (_tmp104_, &_tmp105_, _tmp106_, &_tmp107_);
							}
							_tmp108_ = dx;
							dx = _tmp108_ + 1;
							_tmp109_ = dx;
							if (_tmp109_ == 4) {
								gint _tmp110_;
								dx = 0;
								_tmp110_ = dy;
								dy = _tmp110_ + 1;
							}
						}
						synergia_tile_destroy (&t);
					}
				}
			}
			_synergia_chunk_unref0 (c);
		}
		_g_object_unref0 (_c_list);
	}
	result = TRUE;
	return result;
}


static void synergia_map_class_init (SynergiaMapClass * klass) {
	synergia_map_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SynergiaMapPrivate));
	STK_WIDGET_CLASS (klass)->draw = synergia_map_real_draw;
	G_OBJECT_CLASS (klass)->finalize = synergia_map_finalize;
}


static void synergia_map_instance_init (SynergiaMap * self) {
	self->priv = SYNERGIA_MAP_GET_PRIVATE (self);
}


static void synergia_map_finalize (GObject* obj) {
	SynergiaMap * self;
	self = SYNERGIA_MAP (obj);
	_g_object_unref0 (self->priv->chunks);
	_SDL_FreeSurface0 (self->priv->tileset);
	_g_object_unref0 (self->priv->player);
	_g_object_unref0 (self->priv->characters);
	G_OBJECT_CLASS (synergia_map_parent_class)->finalize (obj);
}


GType synergia_map_get_type (void) {
	static volatile gsize synergia_map_type_id__volatile = 0;
	if (g_once_init_enter (&synergia_map_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SynergiaMapClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) synergia_map_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SynergiaMap), 0, (GInstanceInitFunc) synergia_map_instance_init, NULL };
		GType synergia_map_type_id;
		synergia_map_type_id = g_type_register_static (STK_TYPE_WIDGET, "SynergiaMap", &g_define_type_info, 0);
		g_once_init_leave (&synergia_map_type_id__volatile, synergia_map_type_id);
	}
	return synergia_map_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



