/* widget.c generated by valac 0.16.0, the Vala compiler
 * generated from widget.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <SDL.h>


#define STK_TYPE_WIDGET (stk_widget_get_type ())
#define STK_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), STK_TYPE_WIDGET, StkWidget))
#define STK_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), STK_TYPE_WIDGET, StkWidgetClass))
#define STK_IS_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), STK_TYPE_WIDGET))
#define STK_IS_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), STK_TYPE_WIDGET))
#define STK_WIDGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), STK_TYPE_WIDGET, StkWidgetClass))

typedef struct _StkWidget StkWidget;
typedef struct _StkWidgetClass StkWidgetClass;
typedef struct _StkWidgetPrivate StkWidgetPrivate;

#define STK_TYPE_EVENTS (stk_events_get_type ())
#define STK_EVENTS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), STK_TYPE_EVENTS, StkEvents))
#define STK_EVENTS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), STK_TYPE_EVENTS, StkEventsClass))
#define STK_IS_EVENTS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), STK_TYPE_EVENTS))
#define STK_IS_EVENTS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), STK_TYPE_EVENTS))
#define STK_EVENTS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), STK_TYPE_EVENTS, StkEventsClass))

typedef struct _StkEvents StkEvents;
typedef struct _StkEventsClass StkEventsClass;

struct _StkWidget {
	GObject parent_instance;
	StkWidgetPrivate * priv;
	SDL_Rect rect;
	gboolean focused;
};

struct _StkWidgetClass {
	GObjectClass parent_class;
	gboolean (*draw) (StkWidget* self, SDL_Surface* screen);
};


static gpointer stk_widget_parent_class = NULL;
extern StkEvents* stk_stk_events;

GType stk_widget_get_type (void) G_GNUC_CONST;
enum  {
	STK_WIDGET_DUMMY_PROPERTY
};
gboolean stk_widget_draw (StkWidget* self, SDL_Surface* screen);
static gboolean stk_widget_real_draw (StkWidget* self, SDL_Surface* screen);
StkWidget* stk_widget_new (void);
StkWidget* stk_widget_construct (GType object_type);
gpointer stk_events_ref (gpointer instance);
void stk_events_unref (gpointer instance);
GParamSpec* stk_param_spec_events (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void stk_value_set_events (GValue* value, gpointer v_object);
void stk_value_take_events (GValue* value, gpointer v_object);
gpointer stk_value_get_events (const GValue* value);
GType stk_events_get_type (void) G_GNUC_CONST;
void stk_widget_onmousemove (StkWidget* self, SDL_MouseMotionEvent* e);
static void _stk_widget_onmousemove_stk_events_mousemove (StkEvents* _sender, SDL_MouseMotionEvent* e, gpointer self);
gboolean stk_widget_collides (StkWidget* self, gint x, gint y);
static void stk_widget_finalize (GObject* obj);


static gboolean stk_widget_real_draw (StkWidget* self, SDL_Surface* screen) {
	gboolean result = FALSE;
	SDL_Surface* _tmp0_;
	gint _tmp1_;
	SDL_Surface* _tmp2_;
	gint _tmp3_;
	g_return_val_if_fail (screen != NULL, FALSE);
	_tmp0_ = screen;
	_tmp1_ = _tmp0_->w;
	self->rect.w = (guint16) _tmp1_;
	_tmp2_ = screen;
	_tmp3_ = _tmp2_->h;
	self->rect.h = (guint16) _tmp3_;
	result = TRUE;
	return result;
}


gboolean stk_widget_draw (StkWidget* self, SDL_Surface* screen) {
	g_return_val_if_fail (self != NULL, FALSE);
	return STK_WIDGET_GET_CLASS (self)->draw (self, screen);
}


static void _stk_widget_onmousemove_stk_events_mousemove (StkEvents* _sender, SDL_MouseMotionEvent* e, gpointer self) {
	stk_widget_onmousemove (self, e);
}


StkWidget* stk_widget_construct (GType object_type) {
	StkWidget * self = NULL;
	StkEvents* _tmp0_;
	self = (StkWidget*) g_object_new (object_type, NULL);
	_tmp0_ = stk_stk_events;
	g_signal_connect_object (_tmp0_, "mousemove", (GCallback) _stk_widget_onmousemove_stk_events_mousemove, self, 0);
	return self;
}


StkWidget* stk_widget_new (void) {
	return stk_widget_construct (STK_TYPE_WIDGET);
}


void stk_widget_onmousemove (StkWidget* self, SDL_MouseMotionEvent* e) {
	gboolean _tmp0_ = FALSE;
	SDL_MouseMotionEvent _tmp1_;
	guint16 _tmp2_;
	SDL_MouseMotionEvent _tmp3_;
	guint16 _tmp4_;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp7_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (e != NULL);
	_tmp1_ = *e;
	_tmp2_ = _tmp1_.x;
	_tmp3_ = *e;
	_tmp4_ = _tmp3_.y;
	_tmp5_ = stk_widget_collides (self, (gint) _tmp2_, (gint) _tmp4_);
	if (_tmp5_) {
		gboolean _tmp6_;
		_tmp6_ = self->focused;
		_tmp0_ = !_tmp6_;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp7_ = _tmp0_;
	if (_tmp7_) {
		g_signal_emit_by_name (self, "focus");
		self->focused = TRUE;
	} else {
		gboolean _tmp8_ = FALSE;
		SDL_MouseMotionEvent _tmp9_;
		guint16 _tmp10_;
		SDL_MouseMotionEvent _tmp11_;
		guint16 _tmp12_;
		gboolean _tmp13_ = FALSE;
		gboolean _tmp15_;
		_tmp9_ = *e;
		_tmp10_ = _tmp9_.x;
		_tmp11_ = *e;
		_tmp12_ = _tmp11_.y;
		_tmp13_ = stk_widget_collides (self, (gint) _tmp10_, (gint) _tmp12_);
		if (!_tmp13_) {
			gboolean _tmp14_;
			_tmp14_ = self->focused;
			_tmp8_ = _tmp14_;
		} else {
			_tmp8_ = FALSE;
		}
		_tmp15_ = _tmp8_;
		if (_tmp15_) {
			g_signal_emit_by_name (self, "blur");
			self->focused = FALSE;
		}
	}
}


gboolean stk_widget_collides (StkWidget* self, gint x, gint y) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gint _tmp3_;
	SDL_Rect _tmp4_;
	gint16 _tmp5_;
	gboolean _tmp9_;
	gboolean _tmp15_;
	gboolean _tmp21_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp3_ = x;
	_tmp4_ = self->rect;
	_tmp5_ = _tmp4_.x;
	if (_tmp3_ >= (_tmp5_ + 2)) {
		gint _tmp6_;
		SDL_Rect _tmp7_;
		gint16 _tmp8_;
		_tmp6_ = y;
		_tmp7_ = self->rect;
		_tmp8_ = _tmp7_.y;
		_tmp2_ = _tmp6_ >= (_tmp8_ + 2);
	} else {
		_tmp2_ = FALSE;
	}
	_tmp9_ = _tmp2_;
	if (_tmp9_) {
		gint _tmp10_;
		SDL_Rect _tmp11_;
		gint16 _tmp12_;
		SDL_Rect _tmp13_;
		guint16 _tmp14_;
		_tmp10_ = x;
		_tmp11_ = self->rect;
		_tmp12_ = _tmp11_.x;
		_tmp13_ = self->rect;
		_tmp14_ = _tmp13_.w;
		_tmp1_ = _tmp10_ <= ((_tmp12_ + _tmp14_) - 4);
	} else {
		_tmp1_ = FALSE;
	}
	_tmp15_ = _tmp1_;
	if (_tmp15_) {
		gint _tmp16_;
		SDL_Rect _tmp17_;
		gint16 _tmp18_;
		SDL_Rect _tmp19_;
		guint16 _tmp20_;
		_tmp16_ = y;
		_tmp17_ = self->rect;
		_tmp18_ = _tmp17_.y;
		_tmp19_ = self->rect;
		_tmp20_ = _tmp19_.h;
		_tmp0_ = _tmp16_ <= ((_tmp18_ + _tmp20_) - 4);
	} else {
		_tmp0_ = FALSE;
	}
	_tmp21_ = _tmp0_;
	result = _tmp21_;
	return result;
}


static void stk_widget_class_init (StkWidgetClass * klass) {
	stk_widget_parent_class = g_type_class_peek_parent (klass);
	STK_WIDGET_CLASS (klass)->draw = stk_widget_real_draw;
	G_OBJECT_CLASS (klass)->finalize = stk_widget_finalize;
	g_signal_new ("focus", STK_TYPE_WIDGET, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("blur", STK_TYPE_WIDGET, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void stk_widget_instance_init (StkWidget * self) {
	self->focused = FALSE;
}


static void stk_widget_finalize (GObject* obj) {
	StkWidget * self;
	self = STK_WIDGET (obj);
	G_OBJECT_CLASS (stk_widget_parent_class)->finalize (obj);
}


GType stk_widget_get_type (void) {
	static volatile gsize stk_widget_type_id__volatile = 0;
	if (g_once_init_enter (&stk_widget_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (StkWidgetClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) stk_widget_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (StkWidget), 0, (GInstanceInitFunc) stk_widget_instance_init, NULL };
		GType stk_widget_type_id;
		stk_widget_type_id = g_type_register_static (G_TYPE_OBJECT, "StkWidget", &g_define_type_info, 0);
		g_once_init_leave (&stk_widget_type_id__volatile, stk_widget_type_id);
	}
	return stk_widget_type_id__volatile;
}



