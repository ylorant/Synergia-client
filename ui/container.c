/* container.c generated by valac 0.16.0, the Vala compiler
 * generated from container.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <SDL.h>
#include <gee.h>


#define STK_TYPE_WIDGET (stk_widget_get_type ())
#define STK_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), STK_TYPE_WIDGET, StkWidget))
#define STK_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), STK_TYPE_WIDGET, StkWidgetClass))
#define STK_IS_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), STK_TYPE_WIDGET))
#define STK_IS_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), STK_TYPE_WIDGET))
#define STK_WIDGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), STK_TYPE_WIDGET, StkWidgetClass))

typedef struct _StkWidget StkWidget;
typedef struct _StkWidgetClass StkWidgetClass;
typedef struct _StkWidgetPrivate StkWidgetPrivate;

#define STK_TYPE_CONTAINER (stk_container_get_type ())
#define STK_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), STK_TYPE_CONTAINER, StkContainer))
#define STK_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), STK_TYPE_CONTAINER, StkContainerClass))
#define STK_IS_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), STK_TYPE_CONTAINER))
#define STK_IS_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), STK_TYPE_CONTAINER))
#define STK_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), STK_TYPE_CONTAINER, StkContainerClass))

typedef struct _StkContainer StkContainer;
typedef struct _StkContainerClass StkContainerClass;
typedef struct _StkContainerPrivate StkContainerPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _SDL_FreeSurface0(var) ((var == NULL) ? NULL : (var = (SDL_FreeSurface (var), NULL)))

struct _StkWidget {
	GObject parent_instance;
	StkWidgetPrivate * priv;
	SDL_Rect rect;
	gboolean focused;
};

struct _StkWidgetClass {
	GObjectClass parent_class;
	gboolean (*draw) (StkWidget* self, SDL_Surface* screen);
};

struct _StkContainer {
	StkWidget parent_instance;
	StkContainerPrivate * priv;
	GeeList* widgets;
};

struct _StkContainerClass {
	StkWidgetClass parent_class;
};


static gpointer stk_container_parent_class = NULL;

GType stk_widget_get_type (void) G_GNUC_CONST;
GType stk_container_get_type (void) G_GNUC_CONST;
enum  {
	STK_CONTAINER_DUMMY_PROPERTY
};
StkContainer* stk_container_new (void);
StkContainer* stk_container_construct (GType object_type);
StkWidget* stk_widget_new (void);
StkWidget* stk_widget_construct (GType object_type);
static gboolean stk_container_real_draw (StkWidget* base, SDL_Surface* screen);
gboolean stk_widget_draw (StkWidget* self, SDL_Surface* screen);
void stk_container_add (StkContainer* self, StkWidget* w);
void stk_container_remove (StkContainer* self, StkWidget* w);
void stk_container_clear (StkContainer* self);
gboolean stk_container_contains (StkContainer* self, StkWidget* w);
static void stk_container_finalize (GObject* obj);


StkContainer* stk_container_construct (GType object_type) {
	StkContainer * self = NULL;
	GeeArrayList* _tmp0_;
	self = (StkContainer*) stk_widget_construct (object_type);
	_tmp0_ = gee_array_list_new (STK_TYPE_WIDGET, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	_g_object_unref0 (self->widgets);
	self->widgets = (GeeList*) _tmp0_;
	return self;
}


StkContainer* stk_container_new (void) {
	return stk_container_construct (STK_TYPE_CONTAINER);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gboolean stk_container_real_draw (StkWidget* base, SDL_Surface* screen) {
	StkContainer * self;
	gboolean result = FALSE;
	SDL_Surface* _tmp0_;
	GeeList* _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	self = (StkContainer*) base;
	g_return_val_if_fail (screen != NULL, FALSE);
	_tmp0_ = screen;
	STK_WIDGET_CLASS (stk_container_parent_class)->draw (STK_WIDGET (self), _tmp0_);
	_tmp1_ = self->widgets;
	_tmp2_ = gee_collection_get_size ((GeeCollection*) _tmp1_);
	_tmp3_ = _tmp2_;
	if (_tmp3_ > 0) {
		SDL_Surface* _tmp4_;
		gint _tmp5_;
		GeeList* _tmp6_;
		gint _tmp7_;
		gint _tmp8_;
		gint height;
		gint i;
		guint32 rmask;
		guint32 gmask;
		guint32 bmask;
		guint32 amask;
		_tmp4_ = screen;
		_tmp5_ = _tmp4_->h;
		_tmp6_ = self->widgets;
		_tmp7_ = gee_collection_get_size ((GeeCollection*) _tmp6_);
		_tmp8_ = _tmp7_;
		height = _tmp5_ / _tmp8_;
		i = 0;
		rmask = (guint32) 0xff000000U;
		gmask = (guint32) 0x00ff0000U;
		bmask = (guint32) 0x0000ff00U;
		amask = (guint32) 0x000000ffU;
		{
			GeeList* _tmp9_;
			GeeList* _tmp10_;
			GeeList* _w_list;
			GeeList* _tmp11_;
			gint _tmp12_;
			gint _tmp13_;
			gint _w_size;
			gint _w_index;
			_tmp9_ = self->widgets;
			_tmp10_ = _g_object_ref0 (_tmp9_);
			_w_list = _tmp10_;
			_tmp11_ = _w_list;
			_tmp12_ = gee_collection_get_size ((GeeCollection*) _tmp11_);
			_tmp13_ = _tmp12_;
			_w_size = _tmp13_;
			_w_index = -1;
			while (TRUE) {
				gint _tmp14_;
				gint _tmp15_;
				gint _tmp16_;
				GeeList* _tmp17_;
				gint _tmp18_;
				gpointer _tmp19_ = NULL;
				StkWidget* w;
				SDL_Surface* _tmp20_;
				gint _tmp21_;
				gint _tmp22_;
				SDL_Surface* _tmp23_;
				SDL_PixelFormat* _tmp24_;
				guchar _tmp25_;
				guint32 _tmp26_;
				guint32 _tmp27_;
				guint32 _tmp28_;
				guint32 _tmp29_;
				SDL_Surface* _tmp30_;
				SDL_Surface* subscreen;
				SDL_Surface* _tmp31_;
				SDL_Surface* _tmp32_;
				SDL_PixelFormat* _tmp33_;
				guint32 _tmp34_ = 0U;
				StkWidget* _tmp35_;
				SDL_Surface* _tmp36_;
				gboolean _tmp37_ = FALSE;
				gboolean ret;
				SDL_Surface* _tmp38_;
				SDL_Surface* _tmp39_;
				SDL_Surface* _tmp40_;
				gint _tmp41_;
				gint _tmp42_;
				SDL_Rect _tmp43_ = {0};
				gboolean _tmp44_;
				gint _tmp65_;
				_tmp14_ = _w_index;
				_w_index = _tmp14_ + 1;
				_tmp15_ = _w_index;
				_tmp16_ = _w_size;
				if (!(_tmp15_ < _tmp16_)) {
					break;
				}
				_tmp17_ = _w_list;
				_tmp18_ = _w_index;
				_tmp19_ = gee_list_get (_tmp17_, _tmp18_);
				w = (StkWidget*) _tmp19_;
				_tmp20_ = screen;
				_tmp21_ = _tmp20_->w;
				_tmp22_ = height;
				_tmp23_ = screen;
				_tmp24_ = _tmp23_->format;
				_tmp25_ = _tmp24_->BitsPerPixel;
				_tmp26_ = rmask;
				_tmp27_ = gmask;
				_tmp28_ = bmask;
				_tmp29_ = amask;
				_tmp30_ = SDL_CreateRGBSurface ((guint32) (((SDL_ASYNCBLIT | SDL_HWSURFACE) | SDL_HWACCEL) | SDL_SRCALPHA), _tmp21_, _tmp22_, (gint) _tmp25_, _tmp26_, _tmp27_, _tmp28_, _tmp29_);
				subscreen = _tmp30_;
				_tmp31_ = subscreen;
				_tmp32_ = subscreen;
				_tmp33_ = _tmp32_->format;
				_tmp34_ = SDL_MapRGBA (_tmp33_, (guchar) 0, (guchar) 0, (guchar) 0, (guchar) 0);
				SDL_FillRect (_tmp31_, NULL, _tmp34_);
				_tmp35_ = w;
				_tmp36_ = subscreen;
				_tmp37_ = stk_widget_draw (_tmp35_, _tmp36_);
				ret = _tmp37_;
				_tmp38_ = subscreen;
				SDL_SetAlpha (_tmp38_, (guint32) 0, (guchar) 0);
				_tmp39_ = subscreen;
				_tmp40_ = screen;
				_tmp41_ = i;
				_tmp42_ = height;
				_tmp43_.x = (gint16) 0;
				_tmp43_.y = (gint16) (_tmp41_ * _tmp42_);
				SDL_UpperBlit (_tmp39_, NULL, _tmp40_, &_tmp43_);
				_tmp44_ = ret;
				if (_tmp44_) {
					StkWidget* _tmp45_;
					SDL_Rect _tmp46_;
					gint16 _tmp47_;
					gint _tmp48_;
					gint _tmp49_;
					StkWidget* _tmp50_;
					SDL_Rect _tmp51_;
					gint16 _tmp52_;
					_tmp45_ = w;
					_tmp46_ = ((StkWidget*) self)->rect;
					_tmp47_ = _tmp46_.y;
					_tmp48_ = i;
					_tmp49_ = height;
					_tmp45_->rect.y = (gint16) (_tmp47_ + (_tmp48_ * _tmp49_));
					_tmp50_ = w;
					_tmp51_ = ((StkWidget*) self)->rect;
					_tmp52_ = _tmp51_.x;
					_tmp50_->rect.x = _tmp52_;
				} else {
					StkWidget* _tmp53_;
					StkWidget* _tmp54_;
					gint16 _tmp55_;
					SDL_Rect _tmp56_;
					gint16 _tmp57_;
					gint _tmp58_;
					gint _tmp59_;
					StkWidget* _tmp60_;
					StkWidget* _tmp61_;
					gint16 _tmp62_;
					SDL_Rect _tmp63_;
					gint16 _tmp64_;
					_tmp53_ = w;
					_tmp54_ = w;
					_tmp55_ = _tmp54_->rect.y;
					_tmp56_ = ((StkWidget*) self)->rect;
					_tmp57_ = _tmp56_.y;
					_tmp58_ = i;
					_tmp59_ = height;
					_tmp54_->rect.y = _tmp55_ + ((gint16) (_tmp57_ + (_tmp58_ * _tmp59_)));
					_tmp60_ = w;
					_tmp61_ = w;
					_tmp62_ = _tmp61_->rect.x;
					_tmp63_ = ((StkWidget*) self)->rect;
					_tmp64_ = _tmp63_.x;
					_tmp61_->rect.x = _tmp62_ + _tmp64_;
				}
				_tmp65_ = i;
				i = _tmp65_ + 1;
				_SDL_FreeSurface0 (subscreen);
				_g_object_unref0 (w);
			}
			_g_object_unref0 (_w_list);
		}
	}
	result = TRUE;
	return result;
}


void stk_container_add (StkContainer* self, StkWidget* w) {
	GeeList* _tmp0_;
	StkWidget* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (w != NULL);
	_tmp0_ = self->widgets;
	_tmp1_ = w;
	gee_collection_add ((GeeCollection*) _tmp0_, _tmp1_);
}


void stk_container_remove (StkContainer* self, StkWidget* w) {
	GeeList* _tmp0_;
	StkWidget* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (w != NULL);
	_tmp0_ = self->widgets;
	_tmp1_ = w;
	gee_collection_remove ((GeeCollection*) _tmp0_, _tmp1_);
}


void stk_container_clear (StkContainer* self) {
	GeeList* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->widgets;
	gee_collection_clear ((GeeCollection*) _tmp0_);
}


gboolean stk_container_contains (StkContainer* self, StkWidget* w) {
	gboolean result = FALSE;
	GeeList* _tmp0_;
	StkWidget* _tmp1_;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (w != NULL, FALSE);
	_tmp0_ = self->widgets;
	_tmp1_ = w;
	_tmp2_ = gee_collection_contains ((GeeCollection*) _tmp0_, _tmp1_);
	result = _tmp2_;
	return result;
}


static void stk_container_class_init (StkContainerClass * klass) {
	stk_container_parent_class = g_type_class_peek_parent (klass);
	STK_WIDGET_CLASS (klass)->draw = stk_container_real_draw;
	G_OBJECT_CLASS (klass)->finalize = stk_container_finalize;
}


static void stk_container_instance_init (StkContainer * self) {
}


static void stk_container_finalize (GObject* obj) {
	StkContainer * self;
	self = STK_CONTAINER (obj);
	_g_object_unref0 (self->widgets);
	G_OBJECT_CLASS (stk_container_parent_class)->finalize (obj);
}


GType stk_container_get_type (void) {
	static volatile gsize stk_container_type_id__volatile = 0;
	if (g_once_init_enter (&stk_container_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (StkContainerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) stk_container_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (StkContainer), 0, (GInstanceInitFunc) stk_container_instance_init, NULL };
		GType stk_container_type_id;
		stk_container_type_id = g_type_register_static (STK_TYPE_WIDGET, "StkContainer", &g_define_type_info, 0);
		g_once_init_leave (&stk_container_type_id__volatile, stk_container_type_id);
	}
	return stk_container_type_id__volatile;
}



