/* stk.c generated by valac 0.16.0, the Vala compiler
 * generated from stk.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <SDL.h>
#include <gee.h>
#include <SDL_ttf.h>
#include <stdlib.h>
#include <string.h>
#include <gobject/gvaluecollector.h>


#define STK_TYPE_ALIGNMENT (stk_alignment_get_type ())

#define STK_TYPE_STK (stk_stk_get_type ())
#define STK_STK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), STK_TYPE_STK, StkStk))
#define STK_STK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), STK_TYPE_STK, StkStkClass))
#define STK_IS_STK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), STK_TYPE_STK))
#define STK_IS_STK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), STK_TYPE_STK))
#define STK_STK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), STK_TYPE_STK, StkStkClass))

typedef struct _StkStk StkStk;
typedef struct _StkStkClass StkStkClass;
typedef struct _StkStkPrivate StkStkPrivate;

#define STK_TYPE_WIDGET (stk_widget_get_type ())
#define STK_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), STK_TYPE_WIDGET, StkWidget))
#define STK_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), STK_TYPE_WIDGET, StkWidgetClass))
#define STK_IS_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), STK_TYPE_WIDGET))
#define STK_IS_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), STK_TYPE_WIDGET))
#define STK_WIDGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), STK_TYPE_WIDGET, StkWidgetClass))

typedef struct _StkWidget StkWidget;
typedef struct _StkWidgetClass StkWidgetClass;

#define STK_TYPE_CONTAINER (stk_container_get_type ())
#define STK_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), STK_TYPE_CONTAINER, StkContainer))
#define STK_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), STK_TYPE_CONTAINER, StkContainerClass))
#define STK_IS_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), STK_TYPE_CONTAINER))
#define STK_IS_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), STK_TYPE_CONTAINER))
#define STK_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), STK_TYPE_CONTAINER, StkContainerClass))

typedef struct _StkContainer StkContainer;
typedef struct _StkContainerClass StkContainerClass;

#define STK_TYPE_WINDOW (stk_window_get_type ())
#define STK_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), STK_TYPE_WINDOW, StkWindow))
#define STK_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), STK_TYPE_WINDOW, StkWindowClass))
#define STK_IS_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), STK_TYPE_WINDOW))
#define STK_IS_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), STK_TYPE_WINDOW))
#define STK_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), STK_TYPE_WINDOW, StkWindowClass))

typedef struct _StkWindow StkWindow;
typedef struct _StkWindowClass StkWindowClass;

#define STK_TYPE_EVENTS (stk_events_get_type ())
#define STK_EVENTS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), STK_TYPE_EVENTS, StkEvents))
#define STK_EVENTS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), STK_TYPE_EVENTS, StkEventsClass))
#define STK_IS_EVENTS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), STK_TYPE_EVENTS))
#define STK_IS_EVENTS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), STK_TYPE_EVENTS))
#define STK_EVENTS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), STK_TYPE_EVENTS, StkEventsClass))

typedef struct _StkEvents StkEvents;
typedef struct _StkEventsClass StkEventsClass;

#define STK_TYPE_STACK (stk_stack_get_type ())
#define STK_STACK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), STK_TYPE_STACK, StkStack))
#define STK_STACK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), STK_TYPE_STACK, StkStackClass))
#define STK_IS_STACK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), STK_TYPE_STACK))
#define STK_IS_STACK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), STK_TYPE_STACK))
#define STK_STACK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), STK_TYPE_STACK, StkStackClass))

typedef struct _StkStack StkStack;
typedef struct _StkStackClass StkStackClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _stk_events_unref0(var) ((var == NULL) ? NULL : (var = (stk_events_unref (var), NULL)))
typedef struct _StkWidgetPrivate StkWidgetPrivate;
#define _TTF_CloseFont0(var) ((var == NULL) ? NULL : (var = (TTF_CloseFont (var), NULL)))
#define _SDL_FreeSurface0(var) ((var == NULL) ? NULL : (var = (SDL_FreeSurface (var), NULL)))
typedef struct _StkParamSpecStk StkParamSpecStk;

typedef enum  {
	STK_ALIGNMENT_LEFT,
	STK_ALIGNMENT_RIGHT,
	STK_ALIGNMENT_CENTER,
	STK_ALIGNMENT_TOP,
	STK_ALIGNMENT_MIDDLE,
	STK_ALIGNMENT_BOTTOM
} StkAlignment;

struct _StkStk {
	GTypeInstance parent_instance;
	volatile int ref_count;
	StkStkPrivate * priv;
};

struct _StkStkClass {
	GTypeClass parent_class;
	void (*finalize) (StkStk *self);
};

struct _StkWidget {
	GObject parent_instance;
	StkWidgetPrivate * priv;
	SDL_Rect rect;
	gboolean focused;
};

struct _StkWidgetClass {
	GObjectClass parent_class;
	gboolean (*draw) (StkWidget* self, SDL_Surface* screen);
};

struct _StkParamSpecStk {
	GParamSpec parent_instance;
};


static gpointer stk_stk_parent_class = NULL;
static SDL_Surface* stk_stk_screen;
static SDL_Surface* stk_stk_screen = NULL;
static GeeList* stk_stk_windows;
static GeeList* stk_stk_windows = NULL;
extern TTF_Font* stk_stk_font;
TTF_Font* stk_stk_font = NULL;
extern StkEvents* stk_stk_events;
StkEvents* stk_stk_events = NULL;
extern StkStack* stk_stk_workspace;
StkStack* stk_stk_workspace = NULL;
extern gint stk_stk_ticks;
gint stk_stk_ticks = 0;
extern gboolean stk_stk_drawing;
gboolean stk_stk_drawing = FALSE;

GType stk_alignment_get_type (void) G_GNUC_CONST;
gpointer stk_stk_ref (gpointer instance);
void stk_stk_unref (gpointer instance);
GParamSpec* stk_param_spec_stk (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void stk_value_set_stk (GValue* value, gpointer v_object);
void stk_value_take_stk (GValue* value, gpointer v_object);
gpointer stk_value_get_stk (const GValue* value);
GType stk_stk_get_type (void) G_GNUC_CONST;
enum  {
	STK_STK_DUMMY_PROPERTY
};
GType stk_widget_get_type (void) G_GNUC_CONST;
GType stk_container_get_type (void) G_GNUC_CONST;
GType stk_window_get_type (void) G_GNUC_CONST;
gpointer stk_events_ref (gpointer instance);
void stk_events_unref (gpointer instance);
GParamSpec* stk_param_spec_events (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void stk_value_set_events (GValue* value, gpointer v_object);
void stk_value_take_events (GValue* value, gpointer v_object);
gpointer stk_value_get_events (const GValue* value);
GType stk_events_get_type (void) G_GNUC_CONST;
GType stk_stack_get_type (void) G_GNUC_CONST;
void stk_stk_init (SDL_Surface* screen);
StkEvents* stk_events_new (void);
StkEvents* stk_events_construct (GType object_type);
StkStack* stk_stack_new (void);
StkStack* stk_stack_construct (GType object_type);
void stk_stk_add_window (StkWindow* w);
void stk_stk_remove_window (StkWindow* w);
void stk_stk_clear_windows (void);
void stk_stk_set_font (const gchar* fontfile);
void stk_stk_draw (void);
gboolean stk_stack_draw (StkStack* self, SDL_Surface* screen);
gboolean stk_window_draw (StkWindow* self, SDL_Surface* screen);
void stk_stk_main_iteration (void);
void stk_events_process (StkEvents* self);
guint32 stk_stk_color_to_uint32 (SDL_Color c);
StkStk* stk_stk_new (void);
StkStk* stk_stk_construct (GType object_type);
static void stk_stk_finalize (StkStk* obj);


GType stk_alignment_get_type (void) {
	static volatile gsize stk_alignment_type_id__volatile = 0;
	if (g_once_init_enter (&stk_alignment_type_id__volatile)) {
		static const GEnumValue values[] = {{STK_ALIGNMENT_LEFT, "STK_ALIGNMENT_LEFT", "left"}, {STK_ALIGNMENT_RIGHT, "STK_ALIGNMENT_RIGHT", "right"}, {STK_ALIGNMENT_CENTER, "STK_ALIGNMENT_CENTER", "center"}, {STK_ALIGNMENT_TOP, "STK_ALIGNMENT_TOP", "top"}, {STK_ALIGNMENT_MIDDLE, "STK_ALIGNMENT_MIDDLE", "middle"}, {STK_ALIGNMENT_BOTTOM, "STK_ALIGNMENT_BOTTOM", "bottom"}, {0, NULL, NULL}};
		GType stk_alignment_type_id;
		stk_alignment_type_id = g_enum_register_static ("StkAlignment", values);
		g_once_init_leave (&stk_alignment_type_id__volatile, stk_alignment_type_id);
	}
	return stk_alignment_type_id__volatile;
}


void stk_stk_init (SDL_Surface* screen) {
	SDL_Surface* _tmp0_;
	GeeArrayList* _tmp1_;
	StkEvents* _tmp2_;
	StkStack* _tmp3_;
	StkStack* _tmp4_;
	StkStack* _tmp5_;
	g_return_if_fail (screen != NULL);
	stk_stk_ticks = 0;
	_tmp0_ = screen;
	stk_stk_screen = _tmp0_;
	stk_stk_drawing = FALSE;
	_tmp1_ = gee_array_list_new (STK_TYPE_WINDOW, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	_g_object_unref0 (stk_stk_windows);
	stk_stk_windows = (GeeList*) _tmp1_;
	_tmp2_ = stk_events_new ();
	_stk_events_unref0 (stk_stk_events);
	stk_stk_events = _tmp2_;
	_tmp3_ = stk_stack_new ();
	_g_object_unref0 (stk_stk_workspace);
	stk_stk_workspace = _tmp3_;
	_tmp4_ = stk_stk_workspace;
	((StkWidget*) _tmp4_)->rect.x = (gint16) 0;
	_tmp5_ = stk_stk_workspace;
	((StkWidget*) _tmp5_)->rect.y = (gint16) 0;
	SDL_EnableUNICODE (1);
	SDL_EnableKeyRepeat (500, 50);
}


void stk_stk_add_window (StkWindow* w) {
	GeeList* _tmp0_;
	StkWindow* _tmp1_;
	g_return_if_fail (w != NULL);
	_tmp0_ = stk_stk_windows;
	_tmp1_ = w;
	gee_collection_add ((GeeCollection*) _tmp0_, _tmp1_);
}


void stk_stk_remove_window (StkWindow* w) {
	GeeList* _tmp0_;
	StkWindow* _tmp1_;
	g_return_if_fail (w != NULL);
	_tmp0_ = stk_stk_windows;
	_tmp1_ = w;
	gee_collection_remove ((GeeCollection*) _tmp0_, _tmp1_);
}


void stk_stk_clear_windows (void) {
	GeeList* _tmp0_;
	_tmp0_ = stk_stk_windows;
	gee_collection_clear ((GeeCollection*) _tmp0_);
}


void stk_stk_set_font (const gchar* fontfile) {
	TTF_Font* _tmp0_;
	const gchar* _tmp1_;
	TTF_Font* _tmp2_;
	g_return_if_fail (fontfile != NULL);
	_tmp0_ = stk_stk_font;
	if (_tmp0_ != NULL) {
		_TTF_CloseFont0 (stk_stk_font);
		stk_stk_font = NULL;
	}
	_tmp1_ = fontfile;
	_tmp2_ = TTF_OpenFont (_tmp1_, 12);
	_TTF_CloseFont0 (stk_stk_font);
	stk_stk_font = _tmp2_;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void stk_stk_draw (void) {
	guint32 rmask;
	guint32 gmask;
	guint32 bmask;
	guint32 amask;
	SDL_Surface* _tmp0_;
	gint _tmp1_;
	SDL_Surface* _tmp2_;
	gint _tmp3_;
	SDL_Surface* _tmp4_;
	SDL_PixelFormat* _tmp5_;
	guchar _tmp6_;
	guint32 _tmp7_;
	guint32 _tmp8_;
	guint32 _tmp9_;
	guint32 _tmp10_;
	SDL_Surface* _tmp11_;
	SDL_Surface* subscreen;
	SDL_Surface* _tmp12_;
	SDL_Surface* _tmp13_;
	SDL_PixelFormat* _tmp14_;
	guint32 _tmp15_ = 0U;
	StkStack* _tmp16_;
	SDL_Surface* _tmp17_;
	SDL_Surface* _tmp18_;
	SDL_Surface* _tmp19_;
	SDL_Surface* _tmp20_;
	gint _tmp34_;
	gint _tmp35_;
	rmask = (guint32) 0xff000000U;
	gmask = (guint32) 0x00ff0000U;
	bmask = (guint32) 0x0000ff00U;
	amask = (guint32) 0x000000ffU;
	_tmp0_ = stk_stk_screen;
	_tmp1_ = _tmp0_->w;
	_tmp2_ = stk_stk_screen;
	_tmp3_ = _tmp2_->h;
	_tmp4_ = stk_stk_screen;
	_tmp5_ = _tmp4_->format;
	_tmp6_ = _tmp5_->BitsPerPixel;
	_tmp7_ = rmask;
	_tmp8_ = gmask;
	_tmp9_ = bmask;
	_tmp10_ = amask;
	_tmp11_ = SDL_CreateRGBSurface ((guint32) (SDL_HWSURFACE | SDL_SRCALPHA), _tmp1_, _tmp3_, (gint) _tmp6_, _tmp7_, _tmp8_, _tmp9_, _tmp10_);
	subscreen = _tmp11_;
	_tmp12_ = subscreen;
	_tmp13_ = subscreen;
	_tmp14_ = _tmp13_->format;
	_tmp15_ = SDL_MapRGBA (_tmp14_, (guchar) 0, (guchar) 0, (guchar) 0, (guchar) 0);
	SDL_FillRect (_tmp12_, NULL, _tmp15_);
	stk_stk_drawing = TRUE;
	_tmp16_ = stk_stk_workspace;
	_tmp17_ = subscreen;
	stk_stack_draw (_tmp16_, _tmp17_);
	_tmp18_ = subscreen;
	SDL_SetAlpha (_tmp18_, (guint32) 0, (guchar) 0);
	_tmp19_ = subscreen;
	_tmp20_ = stk_stk_screen;
	SDL_UpperBlit (_tmp19_, NULL, _tmp20_, NULL);
	{
		GeeList* _tmp21_;
		GeeList* _tmp22_;
		GeeList* _win_list;
		GeeList* _tmp23_;
		gint _tmp24_;
		gint _tmp25_;
		gint _win_size;
		gint _win_index;
		_tmp21_ = stk_stk_windows;
		_tmp22_ = _g_object_ref0 (_tmp21_);
		_win_list = _tmp22_;
		_tmp23_ = _win_list;
		_tmp24_ = gee_collection_get_size ((GeeCollection*) _tmp23_);
		_tmp25_ = _tmp24_;
		_win_size = _tmp25_;
		_win_index = -1;
		while (TRUE) {
			gint _tmp26_;
			gint _tmp27_;
			gint _tmp28_;
			GeeList* _tmp29_;
			gint _tmp30_;
			gpointer _tmp31_ = NULL;
			StkWindow* win;
			StkWindow* _tmp32_;
			SDL_Surface* _tmp33_;
			_tmp26_ = _win_index;
			_win_index = _tmp26_ + 1;
			_tmp27_ = _win_index;
			_tmp28_ = _win_size;
			if (!(_tmp27_ < _tmp28_)) {
				break;
			}
			_tmp29_ = _win_list;
			_tmp30_ = _win_index;
			_tmp31_ = gee_list_get (_tmp29_, _tmp30_);
			win = (StkWindow*) _tmp31_;
			_tmp32_ = win;
			_tmp33_ = stk_stk_screen;
			stk_window_draw (_tmp32_, _tmp33_);
			_g_object_unref0 (win);
		}
		_g_object_unref0 (_win_list);
	}
	stk_stk_drawing = FALSE;
	_tmp34_ = stk_stk_ticks;
	stk_stk_ticks = _tmp34_ + 1;
	_tmp35_ = stk_stk_ticks;
	if (_tmp35_ == 60) {
		stk_stk_ticks = 0;
	}
	_SDL_FreeSurface0 (subscreen);
}


void stk_stk_main_iteration (void) {
	StkEvents* _tmp0_;
	stk_stk_draw ();
	_tmp0_ = stk_stk_events;
	stk_events_process (_tmp0_);
}


guint32 stk_stk_color_to_uint32 (SDL_Color c) {
	guint32 result = 0U;
	SDL_Color _tmp0_;
	guchar _tmp1_;
	gint ret;
	gint _tmp2_;
	gint _tmp3_;
	SDL_Color _tmp4_;
	guchar _tmp5_;
	gint _tmp6_;
	gint _tmp7_;
	SDL_Color _tmp8_;
	guchar _tmp9_;
	gint _tmp10_;
	gint _tmp11_;
	SDL_Color _tmp12_;
	guchar _tmp13_;
	_tmp0_ = c;
	_tmp1_ = _tmp0_.r;
	ret = (gint) _tmp1_;
	_tmp2_ = ret;
	ret = _tmp2_ << 8;
	_tmp3_ = ret;
	_tmp4_ = c;
	_tmp5_ = _tmp4_.g;
	ret = _tmp3_ + _tmp5_;
	_tmp6_ = ret;
	ret = _tmp6_ << 8;
	_tmp7_ = ret;
	_tmp8_ = c;
	_tmp9_ = _tmp8_.b;
	ret = _tmp7_ + _tmp9_;
	_tmp10_ = ret;
	ret = _tmp10_ << 8;
	_tmp11_ = ret;
	_tmp12_ = c;
	_tmp13_ = _tmp12_.unused;
	ret = _tmp11_ + _tmp13_;
	result = (guint32) ret;
	return result;
}


StkStk* stk_stk_construct (GType object_type) {
	StkStk* self = NULL;
	self = (StkStk*) g_type_create_instance (object_type);
	return self;
}


StkStk* stk_stk_new (void) {
	return stk_stk_construct (STK_TYPE_STK);
}


static void stk_value_stk_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void stk_value_stk_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		stk_stk_unref (value->data[0].v_pointer);
	}
}


static void stk_value_stk_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = stk_stk_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer stk_value_stk_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* stk_value_stk_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		StkStk* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = stk_stk_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* stk_value_stk_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	StkStk** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = stk_stk_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* stk_param_spec_stk (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	StkParamSpecStk* spec;
	g_return_val_if_fail (g_type_is_a (object_type, STK_TYPE_STK), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer stk_value_get_stk (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, STK_TYPE_STK), NULL);
	return value->data[0].v_pointer;
}


void stk_value_set_stk (GValue* value, gpointer v_object) {
	StkStk* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, STK_TYPE_STK));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, STK_TYPE_STK));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		stk_stk_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		stk_stk_unref (old);
	}
}


void stk_value_take_stk (GValue* value, gpointer v_object) {
	StkStk* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, STK_TYPE_STK));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, STK_TYPE_STK));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		stk_stk_unref (old);
	}
}


static void stk_stk_class_init (StkStkClass * klass) {
	stk_stk_parent_class = g_type_class_peek_parent (klass);
	STK_STK_CLASS (klass)->finalize = stk_stk_finalize;
}


static void stk_stk_instance_init (StkStk * self) {
	self->ref_count = 1;
}


static void stk_stk_finalize (StkStk* obj) {
	StkStk * self;
	self = STK_STK (obj);
}


GType stk_stk_get_type (void) {
	static volatile gsize stk_stk_type_id__volatile = 0;
	if (g_once_init_enter (&stk_stk_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { stk_value_stk_init, stk_value_stk_free_value, stk_value_stk_copy_value, stk_value_stk_peek_pointer, "p", stk_value_stk_collect_value, "p", stk_value_stk_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (StkStkClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) stk_stk_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (StkStk), 0, (GInstanceInitFunc) stk_stk_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType stk_stk_type_id;
		stk_stk_type_id = g_type_register_fundamental (g_type_fundamental_next (), "StkStk", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&stk_stk_type_id__volatile, stk_stk_type_id);
	}
	return stk_stk_type_id__volatile;
}


gpointer stk_stk_ref (gpointer instance) {
	StkStk* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void stk_stk_unref (gpointer instance) {
	StkStk* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		STK_STK_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



