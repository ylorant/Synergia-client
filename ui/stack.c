/* stack.c generated by valac 0.16.0, the Vala compiler
 * generated from stack.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <SDL.h>
#include <gee.h>


#define STK_TYPE_WIDGET (stk_widget_get_type ())
#define STK_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), STK_TYPE_WIDGET, StkWidget))
#define STK_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), STK_TYPE_WIDGET, StkWidgetClass))
#define STK_IS_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), STK_TYPE_WIDGET))
#define STK_IS_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), STK_TYPE_WIDGET))
#define STK_WIDGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), STK_TYPE_WIDGET, StkWidgetClass))

typedef struct _StkWidget StkWidget;
typedef struct _StkWidgetClass StkWidgetClass;
typedef struct _StkWidgetPrivate StkWidgetPrivate;

#define STK_TYPE_CONTAINER (stk_container_get_type ())
#define STK_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), STK_TYPE_CONTAINER, StkContainer))
#define STK_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), STK_TYPE_CONTAINER, StkContainerClass))
#define STK_IS_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), STK_TYPE_CONTAINER))
#define STK_IS_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), STK_TYPE_CONTAINER))
#define STK_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), STK_TYPE_CONTAINER, StkContainerClass))

typedef struct _StkContainer StkContainer;
typedef struct _StkContainerClass StkContainerClass;
typedef struct _StkContainerPrivate StkContainerPrivate;

#define STK_TYPE_STACK (stk_stack_get_type ())
#define STK_STACK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), STK_TYPE_STACK, StkStack))
#define STK_STACK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), STK_TYPE_STACK, StkStackClass))
#define STK_IS_STACK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), STK_TYPE_STACK))
#define STK_IS_STACK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), STK_TYPE_STACK))
#define STK_STACK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), STK_TYPE_STACK, StkStackClass))

typedef struct _StkStack StkStack;
typedef struct _StkStackClass StkStackClass;
typedef struct _StkStackPrivate StkStackPrivate;
#define _SDL_FreeSurface0(var) ((var == NULL) ? NULL : (var = (SDL_FreeSurface (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

struct _StkWidget {
	GObject parent_instance;
	StkWidgetPrivate * priv;
	SDL_Rect rect;
	gboolean focused;
};

struct _StkWidgetClass {
	GObjectClass parent_class;
	gboolean (*draw) (StkWidget* self, SDL_Surface* screen);
};

struct _StkContainer {
	StkWidget parent_instance;
	StkContainerPrivate * priv;
	GeeList* widgets;
};

struct _StkContainerClass {
	StkWidgetClass parent_class;
};

struct _StkStack {
	StkContainer parent_instance;
	StkStackPrivate * priv;
};

struct _StkStackClass {
	StkContainerClass parent_class;
};


static gpointer stk_stack_parent_class = NULL;

GType stk_widget_get_type (void) G_GNUC_CONST;
GType stk_container_get_type (void) G_GNUC_CONST;
GType stk_stack_get_type (void) G_GNUC_CONST;
enum  {
	STK_STACK_DUMMY_PROPERTY
};
StkStack* stk_stack_new (void);
StkStack* stk_stack_construct (GType object_type);
StkContainer* stk_container_new (void);
StkContainer* stk_container_construct (GType object_type);
void stk_stack_show (StkStack* self, StkWidget* w);
void stk_stack_hide (StkStack* self, StkWidget* w);
gboolean stk_stack_draw (StkStack* self, SDL_Surface* screen);
gboolean stk_widget_draw (StkWidget* self, SDL_Surface* screen);


StkStack* stk_stack_construct (GType object_type) {
	StkStack * self = NULL;
	self = (StkStack*) stk_container_construct (object_type);
	return self;
}


StkStack* stk_stack_new (void) {
	return stk_stack_construct (STK_TYPE_STACK);
}


void stk_stack_show (StkStack* self, StkWidget* w) {
	GeeList* _tmp0_;
	StkWidget* _tmp1_;
	gboolean _tmp2_ = FALSE;
	GeeList* _tmp5_;
	StkWidget* _tmp6_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (w != NULL);
	_tmp0_ = ((StkContainer*) self)->widgets;
	_tmp1_ = w;
	_tmp2_ = gee_collection_contains ((GeeCollection*) _tmp0_, _tmp1_);
	if (_tmp2_) {
		GeeList* _tmp3_;
		StkWidget* _tmp4_;
		_tmp3_ = ((StkContainer*) self)->widgets;
		_tmp4_ = w;
		gee_collection_remove ((GeeCollection*) _tmp3_, _tmp4_);
	}
	_tmp5_ = ((StkContainer*) self)->widgets;
	_tmp6_ = w;
	gee_collection_add ((GeeCollection*) _tmp5_, _tmp6_);
}


void stk_stack_hide (StkStack* self, StkWidget* w) {
	GeeList* _tmp0_;
	StkWidget* _tmp1_;
	gboolean _tmp2_ = FALSE;
	GeeList* _tmp5_;
	StkWidget* _tmp6_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (w != NULL);
	_tmp0_ = ((StkContainer*) self)->widgets;
	_tmp1_ = w;
	_tmp2_ = gee_collection_contains ((GeeCollection*) _tmp0_, _tmp1_);
	if (_tmp2_) {
		GeeList* _tmp3_;
		StkWidget* _tmp4_;
		_tmp3_ = ((StkContainer*) self)->widgets;
		_tmp4_ = w;
		gee_collection_remove ((GeeCollection*) _tmp3_, _tmp4_);
	}
	_tmp5_ = ((StkContainer*) self)->widgets;
	_tmp6_ = w;
	gee_list_insert (_tmp5_, 0, _tmp6_);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


gboolean stk_stack_draw (StkStack* self, SDL_Surface* screen) {
	gboolean result = FALSE;
	SDL_Surface* _tmp0_;
	gint _tmp1_;
	SDL_Surface* _tmp2_;
	gint _tmp3_;
	GeeList* _tmp4_;
	gint _tmp5_;
	gint _tmp6_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (screen != NULL, FALSE);
	_tmp0_ = screen;
	_tmp1_ = _tmp0_->w;
	((StkWidget*) self)->rect.w = (guint16) _tmp1_;
	_tmp2_ = screen;
	_tmp3_ = _tmp2_->h;
	((StkWidget*) self)->rect.h = (guint16) _tmp3_;
	_tmp4_ = ((StkContainer*) self)->widgets;
	_tmp5_ = gee_collection_get_size ((GeeCollection*) _tmp4_);
	_tmp6_ = _tmp5_;
	if (_tmp6_ > 0) {
		guint32 rmask;
		guint32 gmask;
		guint32 bmask;
		guint32 amask;
		rmask = (guint32) 0xff000000U;
		gmask = (guint32) 0x00ff0000U;
		bmask = (guint32) 0x0000ff00U;
		amask = (guint32) 0x000000ffU;
		{
			GeeList* _tmp7_;
			GeeList* _tmp8_;
			GeeList* _w_list;
			GeeList* _tmp9_;
			gint _tmp10_;
			gint _tmp11_;
			gint _w_size;
			gint _w_index;
			_tmp7_ = ((StkContainer*) self)->widgets;
			_tmp8_ = _g_object_ref0 (_tmp7_);
			_w_list = _tmp8_;
			_tmp9_ = _w_list;
			_tmp10_ = gee_collection_get_size ((GeeCollection*) _tmp9_);
			_tmp11_ = _tmp10_;
			_w_size = _tmp11_;
			_w_index = -1;
			while (TRUE) {
				gint _tmp12_;
				gint _tmp13_;
				gint _tmp14_;
				GeeList* _tmp15_;
				gint _tmp16_;
				gpointer _tmp17_ = NULL;
				StkWidget* w;
				SDL_Surface* _tmp18_;
				gint _tmp19_;
				SDL_Surface* _tmp20_;
				gint _tmp21_;
				SDL_Surface* _tmp22_;
				SDL_PixelFormat* _tmp23_;
				guchar _tmp24_;
				guint32 _tmp25_;
				guint32 _tmp26_;
				guint32 _tmp27_;
				guint32 _tmp28_;
				SDL_Surface* _tmp29_;
				SDL_Surface* subscreen;
				SDL_Surface* _tmp30_;
				SDL_Surface* _tmp31_;
				SDL_PixelFormat* _tmp32_;
				guint32 _tmp33_ = 0U;
				StkWidget* _tmp34_;
				SDL_Surface* _tmp35_;
				gboolean _tmp36_ = FALSE;
				gboolean ret;
				SDL_Surface* _tmp37_;
				StkWidget* _tmp38_;
				SDL_Rect _tmp39_;
				SDL_Surface* _tmp40_;
				StkWidget* _tmp41_;
				SDL_Rect _tmp42_;
				gboolean _tmp43_;
				_tmp12_ = _w_index;
				_w_index = _tmp12_ + 1;
				_tmp13_ = _w_index;
				_tmp14_ = _w_size;
				if (!(_tmp13_ < _tmp14_)) {
					break;
				}
				_tmp15_ = _w_list;
				_tmp16_ = _w_index;
				_tmp17_ = gee_list_get (_tmp15_, _tmp16_);
				w = (StkWidget*) _tmp17_;
				_tmp18_ = screen;
				_tmp19_ = _tmp18_->w;
				_tmp20_ = screen;
				_tmp21_ = _tmp20_->h;
				_tmp22_ = screen;
				_tmp23_ = _tmp22_->format;
				_tmp24_ = _tmp23_->BitsPerPixel;
				_tmp25_ = rmask;
				_tmp26_ = gmask;
				_tmp27_ = bmask;
				_tmp28_ = amask;
				_tmp29_ = SDL_CreateRGBSurface ((guint32) ((SDL_HWACCEL | SDL_HWSURFACE) | SDL_SRCALPHA), _tmp19_, _tmp21_, (gint) _tmp24_, _tmp25_, _tmp26_, _tmp27_, _tmp28_);
				subscreen = _tmp29_;
				_tmp30_ = subscreen;
				_tmp31_ = subscreen;
				_tmp32_ = _tmp31_->format;
				_tmp33_ = SDL_MapRGBA (_tmp32_, (guchar) 0, (guchar) 0, (guchar) 0, (guchar) 0);
				SDL_FillRect (_tmp30_, NULL, _tmp33_);
				_tmp34_ = w;
				_tmp35_ = subscreen;
				_tmp36_ = stk_widget_draw (_tmp34_, _tmp35_);
				ret = _tmp36_;
				_tmp37_ = subscreen;
				_tmp38_ = w;
				_tmp39_ = _tmp38_->rect;
				_tmp40_ = screen;
				_tmp41_ = w;
				_tmp42_ = _tmp41_->rect;
				SDL_UpperBlit (_tmp37_, &_tmp39_, _tmp40_, &_tmp42_);
				_tmp43_ = ret;
				if (_tmp43_) {
					StkWidget* _tmp44_;
					SDL_Rect _tmp45_;
					gint16 _tmp46_;
					StkWidget* _tmp47_;
					SDL_Rect _tmp48_;
					gint16 _tmp49_;
					_tmp44_ = w;
					_tmp45_ = ((StkWidget*) self)->rect;
					_tmp46_ = _tmp45_.y;
					_tmp44_->rect.y = _tmp46_;
					_tmp47_ = w;
					_tmp48_ = ((StkWidget*) self)->rect;
					_tmp49_ = _tmp48_.x;
					_tmp47_->rect.x = _tmp49_;
				} else {
					StkWidget* _tmp50_;
					StkWidget* _tmp51_;
					gint16 _tmp52_;
					SDL_Rect _tmp53_;
					gint16 _tmp54_;
					StkWidget* _tmp55_;
					StkWidget* _tmp56_;
					gint16 _tmp57_;
					SDL_Rect _tmp58_;
					gint16 _tmp59_;
					_tmp50_ = w;
					_tmp51_ = w;
					_tmp52_ = _tmp51_->rect.y;
					_tmp53_ = ((StkWidget*) self)->rect;
					_tmp54_ = _tmp53_.y;
					_tmp51_->rect.y = _tmp52_ + _tmp54_;
					_tmp55_ = w;
					_tmp56_ = w;
					_tmp57_ = _tmp56_->rect.x;
					_tmp58_ = ((StkWidget*) self)->rect;
					_tmp59_ = _tmp58_.x;
					_tmp56_->rect.x = _tmp57_ + _tmp59_;
				}
				_SDL_FreeSurface0 (subscreen);
				_g_object_unref0 (w);
			}
			_g_object_unref0 (_w_list);
		}
	}
	result = TRUE;
	return result;
}


static void stk_stack_class_init (StkStackClass * klass) {
	stk_stack_parent_class = g_type_class_peek_parent (klass);
}


static void stk_stack_instance_init (StkStack * self) {
}


GType stk_stack_get_type (void) {
	static volatile gsize stk_stack_type_id__volatile = 0;
	if (g_once_init_enter (&stk_stack_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (StkStackClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) stk_stack_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (StkStack), 0, (GInstanceInitFunc) stk_stack_instance_init, NULL };
		GType stk_stack_type_id;
		stk_stack_type_id = g_type_register_static (STK_TYPE_CONTAINER, "StkStack", &g_define_type_info, 0);
		g_once_init_leave (&stk_stack_type_id__volatile, stk_stack_type_id);
	}
	return stk_stack_type_id__volatile;
}



