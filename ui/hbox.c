/* hbox.c generated by valac 0.16.0, the Vala compiler
 * generated from hbox.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <SDL.h>
#include <gee.h>


#define STK_TYPE_WIDGET (stk_widget_get_type ())
#define STK_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), STK_TYPE_WIDGET, StkWidget))
#define STK_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), STK_TYPE_WIDGET, StkWidgetClass))
#define STK_IS_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), STK_TYPE_WIDGET))
#define STK_IS_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), STK_TYPE_WIDGET))
#define STK_WIDGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), STK_TYPE_WIDGET, StkWidgetClass))

typedef struct _StkWidget StkWidget;
typedef struct _StkWidgetClass StkWidgetClass;
typedef struct _StkWidgetPrivate StkWidgetPrivate;

#define STK_TYPE_CONTAINER (stk_container_get_type ())
#define STK_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), STK_TYPE_CONTAINER, StkContainer))
#define STK_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), STK_TYPE_CONTAINER, StkContainerClass))
#define STK_IS_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), STK_TYPE_CONTAINER))
#define STK_IS_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), STK_TYPE_CONTAINER))
#define STK_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), STK_TYPE_CONTAINER, StkContainerClass))

typedef struct _StkContainer StkContainer;
typedef struct _StkContainerClass StkContainerClass;
typedef struct _StkContainerPrivate StkContainerPrivate;

#define STK_TYPE_HBOX (stk_hbox_get_type ())
#define STK_HBOX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), STK_TYPE_HBOX, StkHBox))
#define STK_HBOX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), STK_TYPE_HBOX, StkHBoxClass))
#define STK_IS_HBOX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), STK_TYPE_HBOX))
#define STK_IS_HBOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), STK_TYPE_HBOX))
#define STK_HBOX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), STK_TYPE_HBOX, StkHBoxClass))

typedef struct _StkHBox StkHBox;
typedef struct _StkHBoxClass StkHBoxClass;
typedef struct _StkHBoxPrivate StkHBoxPrivate;
#define _SDL_FreeSurface0(var) ((var == NULL) ? NULL : (var = (SDL_FreeSurface (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

struct _StkWidget {
	GObject parent_instance;
	StkWidgetPrivate * priv;
	SDL_Rect rect;
	gboolean focused;
};

struct _StkWidgetClass {
	GObjectClass parent_class;
	gboolean (*draw) (StkWidget* self, SDL_Surface* screen);
};

struct _StkContainer {
	StkWidget parent_instance;
	StkContainerPrivate * priv;
	GeeList* widgets;
};

struct _StkContainerClass {
	StkWidgetClass parent_class;
};

struct _StkHBox {
	StkContainer parent_instance;
	StkHBoxPrivate * priv;
};

struct _StkHBoxClass {
	StkContainerClass parent_class;
};


static gpointer stk_hbox_parent_class = NULL;

GType stk_widget_get_type (void) G_GNUC_CONST;
GType stk_container_get_type (void) G_GNUC_CONST;
GType stk_hbox_get_type (void) G_GNUC_CONST;
enum  {
	STK_HBOX_DUMMY_PROPERTY
};
static gboolean stk_hbox_real_draw (StkWidget* base, SDL_Surface* screen);
gboolean stk_widget_draw (StkWidget* self, SDL_Surface* screen);
StkHBox* stk_hbox_new (void);
StkHBox* stk_hbox_construct (GType object_type);
StkContainer* stk_container_new (void);
StkContainer* stk_container_construct (GType object_type);


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gboolean stk_hbox_real_draw (StkWidget* base, SDL_Surface* screen) {
	StkHBox * self;
	gboolean result = FALSE;
	SDL_Surface* _tmp0_;
	gint _tmp1_;
	SDL_Surface* _tmp2_;
	gint _tmp3_;
	GeeList* _tmp4_;
	gint _tmp5_;
	gint _tmp6_;
	self = (StkHBox*) base;
	g_return_val_if_fail (screen != NULL, FALSE);
	_tmp0_ = screen;
	_tmp1_ = _tmp0_->w;
	((StkWidget*) self)->rect.w = (guint16) _tmp1_;
	_tmp2_ = screen;
	_tmp3_ = _tmp2_->h;
	((StkWidget*) self)->rect.h = (guint16) _tmp3_;
	_tmp4_ = ((StkContainer*) self)->widgets;
	_tmp5_ = gee_collection_get_size ((GeeCollection*) _tmp4_);
	_tmp6_ = _tmp5_;
	if (_tmp6_ > 0) {
		SDL_Surface* _tmp7_;
		gint _tmp8_;
		GeeList* _tmp9_;
		gint _tmp10_;
		gint _tmp11_;
		gint width;
		gint i;
		guint32 rmask;
		guint32 gmask;
		guint32 bmask;
		guint32 amask;
		_tmp7_ = screen;
		_tmp8_ = _tmp7_->w;
		_tmp9_ = ((StkContainer*) self)->widgets;
		_tmp10_ = gee_collection_get_size ((GeeCollection*) _tmp9_);
		_tmp11_ = _tmp10_;
		width = _tmp8_ / _tmp11_;
		i = 0;
		rmask = (guint32) 0xff000000U;
		gmask = (guint32) 0x00ff0000U;
		bmask = (guint32) 0x0000ff00U;
		amask = (guint32) 0x000000ffU;
		{
			GeeList* _tmp12_;
			GeeList* _tmp13_;
			GeeList* _w_list;
			GeeList* _tmp14_;
			gint _tmp15_;
			gint _tmp16_;
			gint _w_size;
			gint _w_index;
			_tmp12_ = ((StkContainer*) self)->widgets;
			_tmp13_ = _g_object_ref0 (_tmp12_);
			_w_list = _tmp13_;
			_tmp14_ = _w_list;
			_tmp15_ = gee_collection_get_size ((GeeCollection*) _tmp14_);
			_tmp16_ = _tmp15_;
			_w_size = _tmp16_;
			_w_index = -1;
			while (TRUE) {
				gint _tmp17_;
				gint _tmp18_;
				gint _tmp19_;
				GeeList* _tmp20_;
				gint _tmp21_;
				gpointer _tmp22_ = NULL;
				StkWidget* w;
				gint _tmp23_;
				SDL_Surface* _tmp24_;
				gint _tmp25_;
				SDL_Surface* _tmp26_;
				SDL_PixelFormat* _tmp27_;
				guchar _tmp28_;
				guint32 _tmp29_;
				guint32 _tmp30_;
				guint32 _tmp31_;
				guint32 _tmp32_;
				SDL_Surface* _tmp33_;
				SDL_Surface* subscreen;
				SDL_Surface* _tmp34_;
				SDL_Surface* _tmp35_;
				SDL_PixelFormat* _tmp36_;
				guint32 _tmp37_ = 0U;
				StkWidget* _tmp38_;
				SDL_Surface* _tmp39_;
				gboolean _tmp40_ = FALSE;
				gboolean ret;
				SDL_Surface* _tmp41_;
				SDL_Surface* _tmp42_;
				SDL_Surface* _tmp43_;
				gint _tmp44_;
				gint _tmp45_;
				SDL_Rect _tmp46_ = {0};
				gboolean _tmp47_;
				gint _tmp68_;
				_tmp17_ = _w_index;
				_w_index = _tmp17_ + 1;
				_tmp18_ = _w_index;
				_tmp19_ = _w_size;
				if (!(_tmp18_ < _tmp19_)) {
					break;
				}
				_tmp20_ = _w_list;
				_tmp21_ = _w_index;
				_tmp22_ = gee_list_get (_tmp20_, _tmp21_);
				w = (StkWidget*) _tmp22_;
				_tmp23_ = width;
				_tmp24_ = screen;
				_tmp25_ = _tmp24_->h;
				_tmp26_ = screen;
				_tmp27_ = _tmp26_->format;
				_tmp28_ = _tmp27_->BitsPerPixel;
				_tmp29_ = rmask;
				_tmp30_ = gmask;
				_tmp31_ = bmask;
				_tmp32_ = amask;
				_tmp33_ = SDL_CreateRGBSurface ((guint32) ((SDL_HWACCEL | SDL_HWSURFACE) | SDL_SRCALPHA), _tmp23_, _tmp25_, (gint) _tmp28_, _tmp29_, _tmp30_, _tmp31_, _tmp32_);
				subscreen = _tmp33_;
				_tmp34_ = subscreen;
				_tmp35_ = subscreen;
				_tmp36_ = _tmp35_->format;
				_tmp37_ = SDL_MapRGBA (_tmp36_, (guchar) 0, (guchar) 0, (guchar) 0, (guchar) 0);
				SDL_FillRect (_tmp34_, NULL, _tmp37_);
				_tmp38_ = w;
				_tmp39_ = subscreen;
				_tmp40_ = stk_widget_draw (_tmp38_, _tmp39_);
				ret = _tmp40_;
				_tmp41_ = subscreen;
				SDL_SetAlpha (_tmp41_, (guint32) 0, (guchar) 0);
				_tmp42_ = subscreen;
				_tmp43_ = screen;
				_tmp44_ = i;
				_tmp45_ = width;
				_tmp46_.x = (gint16) (_tmp44_ * _tmp45_);
				_tmp46_.y = (gint16) 0;
				SDL_UpperBlit (_tmp42_, NULL, _tmp43_, &_tmp46_);
				_tmp47_ = ret;
				if (_tmp47_) {
					StkWidget* _tmp48_;
					SDL_Rect _tmp49_;
					gint16 _tmp50_;
					gint _tmp51_;
					gint _tmp52_;
					StkWidget* _tmp53_;
					SDL_Rect _tmp54_;
					gint16 _tmp55_;
					_tmp48_ = w;
					_tmp49_ = ((StkWidget*) self)->rect;
					_tmp50_ = _tmp49_.x;
					_tmp51_ = i;
					_tmp52_ = width;
					_tmp48_->rect.x = (gint16) (_tmp50_ + (_tmp51_ * _tmp52_));
					_tmp53_ = w;
					_tmp54_ = ((StkWidget*) self)->rect;
					_tmp55_ = _tmp54_.y;
					_tmp53_->rect.y = _tmp55_;
				} else {
					StkWidget* _tmp56_;
					StkWidget* _tmp57_;
					gint16 _tmp58_;
					SDL_Rect _tmp59_;
					gint16 _tmp60_;
					gint _tmp61_;
					gint _tmp62_;
					StkWidget* _tmp63_;
					StkWidget* _tmp64_;
					gint16 _tmp65_;
					SDL_Rect _tmp66_;
					gint16 _tmp67_;
					_tmp56_ = w;
					_tmp57_ = w;
					_tmp58_ = _tmp57_->rect.x;
					_tmp59_ = ((StkWidget*) self)->rect;
					_tmp60_ = _tmp59_.x;
					_tmp61_ = i;
					_tmp62_ = width;
					_tmp57_->rect.x = _tmp58_ + ((gint16) (_tmp60_ + (_tmp61_ * _tmp62_)));
					_tmp63_ = w;
					_tmp64_ = w;
					_tmp65_ = _tmp64_->rect.y;
					_tmp66_ = ((StkWidget*) self)->rect;
					_tmp67_ = _tmp66_.y;
					_tmp64_->rect.y = _tmp65_ + _tmp67_;
				}
				_tmp68_ = i;
				i = _tmp68_ + 1;
				_SDL_FreeSurface0 (subscreen);
				_g_object_unref0 (w);
			}
			_g_object_unref0 (_w_list);
		}
	}
	result = TRUE;
	return result;
}


StkHBox* stk_hbox_construct (GType object_type) {
	StkHBox * self = NULL;
	self = (StkHBox*) stk_container_construct (object_type);
	return self;
}


StkHBox* stk_hbox_new (void) {
	return stk_hbox_construct (STK_TYPE_HBOX);
}


static void stk_hbox_class_init (StkHBoxClass * klass) {
	stk_hbox_parent_class = g_type_class_peek_parent (klass);
	STK_WIDGET_CLASS (klass)->draw = stk_hbox_real_draw;
}


static void stk_hbox_instance_init (StkHBox * self) {
}


GType stk_hbox_get_type (void) {
	static volatile gsize stk_hbox_type_id__volatile = 0;
	if (g_once_init_enter (&stk_hbox_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (StkHBoxClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) stk_hbox_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (StkHBox), 0, (GInstanceInitFunc) stk_hbox_instance_init, NULL };
		GType stk_hbox_type_id;
		stk_hbox_type_id = g_type_register_static (STK_TYPE_CONTAINER, "StkHBox", &g_define_type_info, 0);
		g_once_init_leave (&stk_hbox_type_id__volatile, stk_hbox_type_id);
	}
	return stk_hbox_type_id__volatile;
}



