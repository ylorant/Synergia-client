/* entry.c generated by valac 0.16.0, the Vala compiler
 * generated from entry.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <SDL.h>
#include <stdlib.h>
#include <string.h>
#include <SDL_keysym.h>
#include <SDL_ttf.h>
#include <SDL_gfxPrimitives.h>


#define STK_TYPE_WIDGET (stk_widget_get_type ())
#define STK_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), STK_TYPE_WIDGET, StkWidget))
#define STK_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), STK_TYPE_WIDGET, StkWidgetClass))
#define STK_IS_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), STK_TYPE_WIDGET))
#define STK_IS_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), STK_TYPE_WIDGET))
#define STK_WIDGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), STK_TYPE_WIDGET, StkWidgetClass))

typedef struct _StkWidget StkWidget;
typedef struct _StkWidgetClass StkWidgetClass;
typedef struct _StkWidgetPrivate StkWidgetPrivate;

#define STK_TYPE_ENTRY (stk_entry_get_type ())
#define STK_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), STK_TYPE_ENTRY, StkEntry))
#define STK_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), STK_TYPE_ENTRY, StkEntryClass))
#define STK_IS_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), STK_TYPE_ENTRY))
#define STK_IS_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), STK_TYPE_ENTRY))
#define STK_ENTRY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), STK_TYPE_ENTRY, StkEntryClass))

typedef struct _StkEntry StkEntry;
typedef struct _StkEntryClass StkEntryClass;
typedef struct _StkEntryPrivate StkEntryPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))

#define STK_TYPE_EVENTS (stk_events_get_type ())
#define STK_EVENTS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), STK_TYPE_EVENTS, StkEvents))
#define STK_EVENTS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), STK_TYPE_EVENTS, StkEventsClass))
#define STK_IS_EVENTS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), STK_TYPE_EVENTS))
#define STK_IS_EVENTS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), STK_TYPE_EVENTS))
#define STK_EVENTS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), STK_TYPE_EVENTS, StkEventsClass))

typedef struct _StkEvents StkEvents;
typedef struct _StkEventsClass StkEventsClass;
#define _SDL_FreeSurface0(var) ((var == NULL) ? NULL : (var = (SDL_FreeSurface (var), NULL)))

struct _StkWidget {
	GObject parent_instance;
	StkWidgetPrivate * priv;
	SDL_Rect rect;
	gboolean focused;
};

struct _StkWidgetClass {
	GObjectClass parent_class;
	gboolean (*draw) (StkWidget* self, SDL_Surface* screen);
};

struct _StkEntry {
	StkWidget parent_instance;
	StkEntryPrivate * priv;
	SDL_Color border;
	SDL_Color background;
	gchar* text;
	gboolean hidden;
};

struct _StkEntryClass {
	StkWidgetClass parent_class;
};

struct _StkEntryPrivate {
	gboolean prompted;
	gboolean empty;
};


static gpointer stk_entry_parent_class = NULL;
extern StkEvents* stk_stk_events;
extern TTF_Font* stk_stk_font;

GType stk_widget_get_type (void) G_GNUC_CONST;
GType stk_entry_get_type (void) G_GNUC_CONST;
#define STK_ENTRY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), STK_TYPE_ENTRY, StkEntryPrivate))
enum  {
	STK_ENTRY_DUMMY_PROPERTY
};
StkEntry* stk_entry_new (void);
StkEntry* stk_entry_construct (GType object_type);
StkWidget* stk_widget_new (void);
StkWidget* stk_widget_construct (GType object_type);
gpointer stk_events_ref (gpointer instance);
void stk_events_unref (gpointer instance);
GParamSpec* stk_param_spec_events (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void stk_value_set_events (GValue* value, gpointer v_object);
void stk_value_take_events (GValue* value, gpointer v_object);
gpointer stk_value_get_events (const GValue* value);
GType stk_events_get_type (void) G_GNUC_CONST;
void stk_entry_onclick (StkEntry* self);
static void _stk_entry_onclick_stk_events_mouseleft (StkEvents* _sender, SDL_MouseButtonEvent* e, gpointer self);
void stk_entry_onkeypress (StkEntry* self, SDL_KeyboardEvent* e);
static void _stk_entry_onkeypress_stk_events_keydown (StkEvents* _sender, SDL_KeyboardEvent* e, gpointer self);
StkEntry* stk_entry_new_with_value (const gchar* text);
StkEntry* stk_entry_construct_with_value (GType object_type, const gchar* text);
static gboolean stk_entry_real_draw (StkWidget* base, SDL_Surface* screen);
gboolean stk_widget_draw (StkWidget* self, SDL_Surface* screen);
guint32 stk_stk_color_to_uint32 (SDL_Color c);
static void stk_entry_finalize (GObject* obj);


static void _stk_entry_onclick_stk_events_mouseleft (StkEvents* _sender, SDL_MouseButtonEvent* e, gpointer self) {
	stk_entry_onclick (self);
}


static void _stk_entry_onkeypress_stk_events_keydown (StkEvents* _sender, SDL_KeyboardEvent* e, gpointer self) {
	stk_entry_onkeypress (self, e);
}


StkEntry* stk_entry_construct (GType object_type) {
	StkEntry * self = NULL;
	SDL_Color _tmp0_ = {0};
	SDL_Color _tmp1_ = {0};
	gchar* _tmp2_;
	StkEvents* _tmp3_;
	StkEvents* _tmp4_;
	self = (StkEntry*) stk_widget_construct (object_type);
	_tmp0_.r = (guchar) 0;
	_tmp0_.g = (guchar) 0;
	_tmp0_.b = (guchar) 0;
	_tmp0_.unused = (guchar) 255;
	self->border = _tmp0_;
	_tmp1_.r = (guchar) 255;
	_tmp1_.g = (guchar) 255;
	_tmp1_.b = (guchar) 255;
	_tmp1_.unused = (guchar) 255;
	self->background = _tmp1_;
	_tmp2_ = g_strdup ("");
	_g_free0 (self->text);
	self->text = _tmp2_;
	_tmp3_ = stk_stk_events;
	g_signal_connect_object (_tmp3_, "mouseleft", (GCallback) _stk_entry_onclick_stk_events_mouseleft, self, 0);
	_tmp4_ = stk_stk_events;
	g_signal_connect_object (_tmp4_, "keydown", (GCallback) _stk_entry_onkeypress_stk_events_keydown, self, 0);
	return self;
}


StkEntry* stk_entry_new (void) {
	return stk_entry_construct (STK_TYPE_ENTRY);
}


StkEntry* stk_entry_construct_with_value (GType object_type, const gchar* text) {
	StkEntry * self = NULL;
	const gchar* _tmp0_;
	g_return_val_if_fail (text != NULL, NULL);
	self = (StkEntry*) stk_entry_construct (object_type);
	_tmp0_ = text;
	if (g_strcmp0 (_tmp0_, "") != 0) {
		const gchar* _tmp1_;
		gchar* _tmp2_;
		self->priv->empty = FALSE;
		_tmp1_ = text;
		_tmp2_ = g_strdup (_tmp1_);
		_g_free0 (self->text);
		self->text = _tmp2_;
	}
	return self;
}


StkEntry* stk_entry_new_with_value (const gchar* text) {
	return stk_entry_construct_with_value (STK_TYPE_ENTRY, text);
}


void stk_entry_onclick (StkEntry* self) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = ((StkWidget*) self)->focused;
	if (_tmp0_) {
		self->priv->prompted = TRUE;
	} else {
		self->priv->prompted = FALSE;
	}
}


static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* _tmp0_;
	glong _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* end;
	gchar* _tmp3_;
	_tmp0_ = str;
	_tmp1_ = maxlen;
	_tmp2_ = memchr (_tmp0_, 0, (gsize) _tmp1_);
	end = _tmp2_;
	_tmp3_ = end;
	if (_tmp3_ == NULL) {
		glong _tmp4_;
		_tmp4_ = maxlen;
		result = _tmp4_;
		return result;
	} else {
		gchar* _tmp5_;
		gchar* _tmp6_;
		_tmp5_ = end;
		_tmp6_ = str;
		result = (glong) (_tmp5_ - _tmp6_);
		return result;
	}
}


static gchar* string_substring (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp1_;
	gboolean _tmp3_;
	glong _tmp9_;
	glong _tmp15_;
	glong _tmp18_;
	glong _tmp19_;
	glong _tmp20_;
	glong _tmp21_;
	glong _tmp22_;
	gchar* _tmp23_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = offset;
	if (_tmp1_ >= ((glong) 0)) {
		glong _tmp2_;
		_tmp2_ = len;
		_tmp0_ = _tmp2_ >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	_tmp3_ = _tmp0_;
	if (_tmp3_) {
		glong _tmp4_;
		glong _tmp5_;
		glong _tmp6_ = 0L;
		_tmp4_ = offset;
		_tmp5_ = len;
		_tmp6_ = string_strnlen ((gchar*) self, _tmp4_ + _tmp5_);
		string_length = _tmp6_;
	} else {
		gint _tmp7_;
		gint _tmp8_;
		_tmp7_ = strlen (self);
		_tmp8_ = _tmp7_;
		string_length = (glong) _tmp8_;
	}
	_tmp9_ = offset;
	if (_tmp9_ < ((glong) 0)) {
		glong _tmp10_;
		glong _tmp11_;
		glong _tmp12_;
		_tmp10_ = string_length;
		_tmp11_ = offset;
		offset = _tmp10_ + _tmp11_;
		_tmp12_ = offset;
		g_return_val_if_fail (_tmp12_ >= ((glong) 0), NULL);
	} else {
		glong _tmp13_;
		glong _tmp14_;
		_tmp13_ = offset;
		_tmp14_ = string_length;
		g_return_val_if_fail (_tmp13_ <= _tmp14_, NULL);
	}
	_tmp15_ = len;
	if (_tmp15_ < ((glong) 0)) {
		glong _tmp16_;
		glong _tmp17_;
		_tmp16_ = string_length;
		_tmp17_ = offset;
		len = _tmp16_ - _tmp17_;
	}
	_tmp18_ = offset;
	_tmp19_ = len;
	_tmp20_ = string_length;
	g_return_val_if_fail ((_tmp18_ + _tmp19_) <= _tmp20_, NULL);
	_tmp21_ = offset;
	_tmp22_ = len;
	_tmp23_ = g_strndup (((gchar*) self) + _tmp21_, (gsize) _tmp22_);
	result = _tmp23_;
	return result;
}


void stk_entry_onkeypress (StkEntry* self, SDL_KeyboardEvent* e) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (e != NULL);
	_tmp0_ = self->priv->prompted;
	if (_tmp0_) {
		SDL_KeyboardEvent _tmp1_;
		SDL_keysym _tmp2_;
		int _tmp3_;
		_tmp1_ = *e;
		_tmp2_ = _tmp1_.keysym;
		_tmp3_ = _tmp2_.sym;
		switch (_tmp3_) {
			case SDLK_RETURN:
			{
				break;
			}
			case SDLK_BACKSPACE:
			{
				const gchar* _tmp4_;
				gint _tmp5_;
				gint _tmp6_;
				_tmp4_ = self->text;
				_tmp5_ = strlen (_tmp4_);
				_tmp6_ = _tmp5_;
				if (_tmp6_ > 1) {
					const gchar* _tmp7_;
					const gchar* _tmp8_;
					gint _tmp9_;
					gint _tmp10_;
					gchar* _tmp11_ = NULL;
					_tmp7_ = self->text;
					_tmp8_ = self->text;
					_tmp9_ = strlen (_tmp8_);
					_tmp10_ = _tmp9_;
					_tmp11_ = string_substring (_tmp7_, (glong) 0, (glong) (_tmp10_ - 1));
					_g_free0 (self->text);
					self->text = _tmp11_;
				} else {
					gchar* _tmp12_;
					_tmp12_ = g_strdup ("");
					_g_free0 (self->text);
					self->text = _tmp12_;
					self->priv->empty = TRUE;
				}
				break;
			}
			default:
			{
				const gchar* _tmp13_;
				SDL_KeyboardEvent _tmp14_;
				SDL_keysym _tmp15_;
				guint16 _tmp16_;
				gchar* _tmp17_ = NULL;
				gchar* _tmp18_;
				gchar* _tmp19_;
				self->priv->empty = FALSE;
				_tmp13_ = self->text;
				_tmp14_ = *e;
				_tmp15_ = _tmp14_.keysym;
				_tmp16_ = _tmp15_.unicode;
				_tmp17_ = g_strdup_printf ("%c", (gchar) _tmp16_);
				_tmp18_ = _tmp17_;
				_tmp19_ = g_strconcat (_tmp13_, _tmp18_, NULL);
				_g_free0 (self->text);
				self->text = _tmp19_;
				_g_free0 (_tmp18_);
				break;
			}
		}
	}
}


static gboolean stk_entry_real_draw (StkWidget* base, SDL_Surface* screen) {
	StkEntry * self;
	gboolean result = FALSE;
	SDL_Surface* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* rendertext;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_;
	gboolean _tmp6_;
	TTF_Font* _tmp13_;
	const gchar* _tmp14_;
	SDL_Color _tmp15_;
	SDL_Surface* _tmp16_ = NULL;
	SDL_Surface* text;
	SDL_Surface* _tmp17_;
	gint _tmp18_;
	SDL_Surface* _tmp19_;
	gint _tmp20_;
	SDL_Surface* _tmp21_;
	gint _tmp22_;
	SDL_Surface* _tmp23_;
	gint _tmp24_;
	SDL_Rect _tmp25_ = {0};
	SDL_Rect dst;
	SDL_Surface* _tmp26_;
	SDL_Rect _tmp27_;
	gint16 _tmp28_;
	SDL_Rect _tmp29_;
	gint16 _tmp30_;
	SDL_Rect _tmp31_;
	gint16 _tmp32_;
	SDL_Rect _tmp33_;
	guint16 _tmp34_;
	SDL_Rect _tmp35_;
	gint16 _tmp36_;
	SDL_Rect _tmp37_;
	guint16 _tmp38_;
	SDL_Color _tmp39_;
	guint32 _tmp40_ = 0U;
	SDL_Surface* _tmp41_;
	SDL_Rect _tmp42_;
	gint16 _tmp43_;
	SDL_Rect _tmp44_;
	gint16 _tmp45_;
	SDL_Rect _tmp46_;
	gint16 _tmp47_;
	SDL_Rect _tmp48_;
	guint16 _tmp49_;
	SDL_Rect _tmp50_;
	gint16 _tmp51_;
	SDL_Rect _tmp52_;
	guint16 _tmp53_;
	SDL_Color _tmp54_;
	guint32 _tmp55_ = 0U;
	gboolean _tmp56_ = FALSE;
	gboolean _tmp57_;
	gboolean _tmp59_;
	SDL_Rect _tmp93_;
	gint16 _tmp94_;
	SDL_Rect _tmp95_;
	gint16 _tmp96_;
	SDL_Rect _tmp97_;
	guint16 _tmp98_;
	SDL_Rect _tmp99_;
	guint16 _tmp100_;
	SDL_Rect _tmp101_ = {0};
	gint _tmp102_ = 0;
	SDL_Surface* _tmp103_;
	gint _tmp104_;
	SDL_Surface* _tmp105_;
	gint _tmp106_;
	gint _tmp111_;
	gint16 _tmp112_;
	SDL_Surface* _tmp113_;
	SDL_Surface* _tmp114_;
	SDL_Rect _tmp115_;
	self = (StkEntry*) base;
	g_return_val_if_fail (screen != NULL, FALSE);
	_tmp0_ = screen;
	STK_WIDGET_CLASS (stk_entry_parent_class)->draw (STK_WIDGET (self), _tmp0_);
	_tmp1_ = self->text;
	_tmp2_ = g_strdup (_tmp1_);
	rendertext = _tmp2_;
	_tmp4_ = self->hidden;
	if (_tmp4_) {
		gboolean _tmp5_;
		_tmp5_ = self->priv->empty;
		_tmp3_ = !_tmp5_;
	} else {
		_tmp3_ = FALSE;
	}
	_tmp6_ = _tmp3_;
	if (_tmp6_) {
		const gchar* _tmp7_;
		gint _tmp8_;
		gint _tmp9_;
		gchar* _tmp10_ = NULL;
		_tmp7_ = self->text;
		_tmp8_ = strlen (_tmp7_);
		_tmp9_ = _tmp8_;
		_tmp10_ = g_strnfill ((gsize) _tmp9_, '*');
		_g_free0 (rendertext);
		rendertext = _tmp10_;
	} else {
		gboolean _tmp11_;
		_tmp11_ = self->priv->empty;
		if (_tmp11_) {
			gchar* _tmp12_;
			_tmp12_ = g_strdup (" ");
			_g_free0 (rendertext);
			rendertext = _tmp12_;
		}
	}
	_tmp13_ = stk_stk_font;
	_tmp14_ = rendertext;
	_tmp15_ = self->border;
	_tmp16_ = TTF_RenderText_Blended (_tmp13_, _tmp14_, _tmp15_);
	text = _tmp16_;
	_tmp17_ = screen;
	_tmp18_ = _tmp17_->h;
	_tmp19_ = text;
	_tmp20_ = _tmp19_->h;
	_tmp21_ = screen;
	_tmp22_ = _tmp21_->w;
	_tmp23_ = text;
	_tmp24_ = _tmp23_->h;
	_tmp25_.x = (gint16) 2;
	_tmp25_.y = (gint16) (((_tmp18_ / 2) - (_tmp20_ / 2)) - 2);
	_tmp25_.w = (guint16) ((gint16) (_tmp22_ - 4));
	_tmp25_.h = (guint16) ((gint16) (_tmp24_ + 3));
	dst = _tmp25_;
	_tmp26_ = screen;
	_tmp27_ = dst;
	_tmp28_ = _tmp27_.x;
	_tmp29_ = dst;
	_tmp30_ = _tmp29_.y;
	_tmp31_ = dst;
	_tmp32_ = _tmp31_.x;
	_tmp33_ = dst;
	_tmp34_ = _tmp33_.w;
	_tmp35_ = dst;
	_tmp36_ = _tmp35_.y;
	_tmp37_ = dst;
	_tmp38_ = _tmp37_.h;
	_tmp39_ = self->background;
	_tmp40_ = stk_stk_color_to_uint32 (_tmp39_);
	boxColor (_tmp26_, _tmp28_, _tmp30_, (gint16) (_tmp32_ + _tmp34_), (gint16) (_tmp36_ + _tmp38_), _tmp40_);
	_tmp41_ = screen;
	_tmp42_ = dst;
	_tmp43_ = _tmp42_.x;
	_tmp44_ = dst;
	_tmp45_ = _tmp44_.y;
	_tmp46_ = dst;
	_tmp47_ = _tmp46_.x;
	_tmp48_ = dst;
	_tmp49_ = _tmp48_.w;
	_tmp50_ = dst;
	_tmp51_ = _tmp50_.y;
	_tmp52_ = dst;
	_tmp53_ = _tmp52_.h;
	_tmp54_ = self->border;
	_tmp55_ = stk_stk_color_to_uint32 (_tmp54_);
	rectangleColor (_tmp41_, _tmp43_, _tmp45_, (gint16) (_tmp47_ + _tmp49_), (gint16) (_tmp51_ + _tmp53_), _tmp55_);
	_tmp57_ = self->priv->prompted;
	if (_tmp57_) {
		guint32 _tmp58_ = 0U;
		_tmp58_ = SDL_GetTicks ();
		_tmp56_ = ((_tmp58_ / 1000) % 2) == ((guint32) 0);
	} else {
		_tmp56_ = FALSE;
	}
	_tmp59_ = _tmp56_;
	if (_tmp59_) {
		gboolean _tmp60_;
		_tmp60_ = self->priv->empty;
		if (!_tmp60_) {
			gint _tmp61_ = 0;
			SDL_Surface* _tmp62_;
			gint _tmp63_;
			SDL_Surface* _tmp64_;
			gint _tmp65_;
			SDL_Surface* _tmp70_;
			gint _tmp71_;
			SDL_Surface* _tmp72_;
			gint _tmp73_;
			SDL_Surface* _tmp74_;
			gint _tmp75_;
			SDL_Surface* _tmp76_;
			gint _tmp77_;
			SDL_Surface* _tmp78_;
			gint _tmp79_;
			SDL_Color _tmp80_;
			guint32 _tmp81_ = 0U;
			_tmp62_ = text;
			_tmp63_ = _tmp62_->w;
			_tmp64_ = screen;
			_tmp65_ = _tmp64_->w;
			if (_tmp63_ <= (_tmp65_ - 4)) {
				SDL_Surface* _tmp66_;
				gint _tmp67_;
				_tmp66_ = text;
				_tmp67_ = _tmp66_->w;
				_tmp61_ = _tmp67_ + 4;
			} else {
				SDL_Surface* _tmp68_;
				gint _tmp69_;
				_tmp68_ = screen;
				_tmp69_ = _tmp68_->w;
				_tmp61_ = _tmp69_ - 3;
			}
			_tmp70_ = screen;
			_tmp71_ = _tmp61_;
			_tmp72_ = screen;
			_tmp73_ = _tmp72_->h;
			_tmp74_ = text;
			_tmp75_ = _tmp74_->h;
			_tmp76_ = screen;
			_tmp77_ = _tmp76_->h;
			_tmp78_ = text;
			_tmp79_ = _tmp78_->h;
			_tmp80_ = self->border;
			_tmp81_ = stk_stk_color_to_uint32 (_tmp80_);
			vlineColor (_tmp70_, (gint16) _tmp71_, (gint16) ((_tmp73_ / 2) - (_tmp75_ / 2)), (gint16) ((_tmp77_ / 2) + (_tmp79_ / 2)), _tmp81_);
		} else {
			SDL_Surface* _tmp82_;
			SDL_Surface* _tmp83_;
			gint _tmp84_;
			SDL_Surface* _tmp85_;
			gint _tmp86_;
			SDL_Surface* _tmp87_;
			gint _tmp88_;
			SDL_Surface* _tmp89_;
			gint _tmp90_;
			SDL_Color _tmp91_;
			guint32 _tmp92_ = 0U;
			_tmp82_ = screen;
			_tmp83_ = screen;
			_tmp84_ = _tmp83_->h;
			_tmp85_ = text;
			_tmp86_ = _tmp85_->h;
			_tmp87_ = screen;
			_tmp88_ = _tmp87_->h;
			_tmp89_ = text;
			_tmp90_ = _tmp89_->h;
			_tmp91_ = self->border;
			_tmp92_ = stk_stk_color_to_uint32 (_tmp91_);
			vlineColor (_tmp82_, (gint16) 4, (gint16) ((_tmp84_ / 2) - (_tmp86_ / 2)), (gint16) ((_tmp88_ / 2) + (_tmp90_ / 2)), _tmp92_);
		}
	}
	_tmp93_ = dst;
	_tmp94_ = _tmp93_.x;
	_tmp95_ = dst;
	_tmp96_ = _tmp95_.y;
	_tmp97_ = dst;
	_tmp98_ = _tmp97_.w;
	_tmp99_ = dst;
	_tmp100_ = _tmp99_.h;
	_tmp101_.x = _tmp94_;
	_tmp101_.y = _tmp96_;
	_tmp101_.w = _tmp98_;
	_tmp101_.h = _tmp100_;
	((StkWidget*) self)->rect = _tmp101_;
	_tmp103_ = text;
	_tmp104_ = _tmp103_->w;
	_tmp105_ = screen;
	_tmp106_ = _tmp105_->w;
	if (_tmp104_ > (_tmp106_ - 4)) {
		SDL_Surface* _tmp107_;
		gint _tmp108_;
		SDL_Surface* _tmp109_;
		gint _tmp110_;
		_tmp107_ = screen;
		_tmp108_ = _tmp107_->w;
		_tmp109_ = text;
		_tmp110_ = _tmp109_->w;
		_tmp102_ = (_tmp108_ - _tmp110_) - 3;
	} else {
		_tmp102_ = 4;
	}
	_tmp111_ = _tmp102_;
	dst.x = (gint16) _tmp111_;
	_tmp112_ = dst.y;
	dst.y = (gint16) (_tmp112_ + 2);
	_tmp113_ = text;
	_tmp114_ = screen;
	_tmp115_ = dst;
	SDL_UpperBlit (_tmp113_, NULL, _tmp114_, &_tmp115_);
	result = FALSE;
	_SDL_FreeSurface0 (text);
	_g_free0 (rendertext);
	return result;
}


static void stk_entry_class_init (StkEntryClass * klass) {
	stk_entry_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (StkEntryPrivate));
	STK_WIDGET_CLASS (klass)->draw = stk_entry_real_draw;
	G_OBJECT_CLASS (klass)->finalize = stk_entry_finalize;
	g_signal_new ("clicked", STK_TYPE_ENTRY, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void stk_entry_instance_init (StkEntry * self) {
	self->priv = STK_ENTRY_GET_PRIVATE (self);
	self->priv->prompted = FALSE;
	self->priv->empty = TRUE;
	self->hidden = FALSE;
}


static void stk_entry_finalize (GObject* obj) {
	StkEntry * self;
	self = STK_ENTRY (obj);
	_g_free0 (self->text);
	G_OBJECT_CLASS (stk_entry_parent_class)->finalize (obj);
}


GType stk_entry_get_type (void) {
	static volatile gsize stk_entry_type_id__volatile = 0;
	if (g_once_init_enter (&stk_entry_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (StkEntryClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) stk_entry_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (StkEntry), 0, (GInstanceInitFunc) stk_entry_instance_init, NULL };
		GType stk_entry_type_id;
		stk_entry_type_id = g_type_register_static (STK_TYPE_WIDGET, "StkEntry", &g_define_type_info, 0);
		g_once_init_leave (&stk_entry_type_id__volatile, stk_entry_type_id);
	}
	return stk_entry_type_id__volatile;
}



